<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://vonwind.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://vonwind.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-09-22T09:29:16+00:00</updated><id>https://vonwind.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Hyprland微信快捷键</title><link href="https://vonwind.github.io/blog/2025/Hyprland%E5%BE%AE%E4%BF%A1%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="alternate" type="text/html" title="Hyprland微信快捷键"/><published>2025-09-22T00:00:00+00:00</published><updated>2025-09-22T00:00:00+00:00</updated><id>https://vonwind.github.io/blog/2025/Hyprland%E5%BE%AE%E4%BF%A1%E5%BF%AB%E6%8D%B7%E9%94%AE</id><content type="html" xml:base="https://vonwind.github.io/blog/2025/Hyprland%E5%BE%AE%E4%BF%A1%E5%BF%AB%E6%8D%B7%E9%94%AE/"><![CDATA[<h3 id="自动检测版脚本">自动检测版脚本</h3> <p>保存为 <code class="language-plaintext highlighter-rouge">~/scripts/wechat-toggle.sh</code>：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 自动检测微信窗口 class</span>
get_wechat_class<span class="o">()</span> <span class="o">{</span>
    hyprctl clients | <span class="nb">grep</span> <span class="nt">-i</span> <span class="s2">"wechat"</span> | <span class="nb">grep</span> <span class="s2">"class:"</span> | <span class="nb">head</span> <span class="nt">-n1</span> | <span class="nb">awk</span> <span class="s1">'{print $2}'</span>
<span class="o">}</span>

<span class="nv">WIN_CLASS</span><span class="o">=</span><span class="si">$(</span>get_wechat_class<span class="si">)</span>

<span class="c"># 如果没有检测到，默认用 wechat</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$WIN_CLASS</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nv">WIN_CLASS</span><span class="o">=</span><span class="s2">"wechat"</span>
<span class="k">fi</span>

<span class="c"># 检查微信是否运行</span>
<span class="k">if</span> <span class="o">!</span> pgrep <span class="nt">-i</span> wechat <span class="o">&gt;</span>/dev/null<span class="p">;</span> <span class="k">then</span>
    <span class="c"># 没有运行就启动</span>
    wechat &amp;
    <span class="nb">exit </span>0
<span class="k">fi</span>

<span class="c"># 微信在运行，检查窗口信息</span>
<span class="nv">WIN_INFO</span><span class="o">=</span><span class="si">$(</span>hyprctl clients | <span class="nb">grep</span> <span class="nt">-i</span> <span class="s2">"class: </span><span class="nv">$WIN_CLASS</span><span class="s2">"</span> <span class="nt">-A</span> 10<span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$WIN_INFO</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="c"># 没找到窗口（可能在后台），重新启动</span>
    wechat &amp;
    <span class="nb">exit </span>0
<span class="k">fi</span>

<span class="c"># 如果窗口已聚焦 → 最小化到一个隐藏 workspace</span>
<span class="k">if </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_INFO</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"focused: yes"</span><span class="p">;</span> <span class="k">then
    </span>hyprctl dispatch movetoworkspacesilent special:hidden <span class="s2">"class:^(?i)</span><span class="nv">$WIN_CLASS</span><span class="s2">$"</span>
<span class="k">else</span>
    <span class="c"># 否则聚焦到它</span>
    hyprctl dispatch focuswindow <span class="s2">"class:^(?i)</span><span class="nv">$WIN_CLASS</span><span class="s2">$"</span>
<span class="k">fi</span>
</code></pre></div></div> <h3 id="使用方法">使用方法</h3> <ol> <li>给权限： <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x ~/scripts/wechat-toggle.sh
</code></pre></div> </div> </li> <li>在 <code class="language-plaintext highlighter-rouge">~/.config/hypr/hyprland.conf</code> 里添加： <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">bind</span> <span class="o">=</span> SUPER, W, <span class="nb">exec</span>, ~/scripts/wechat-toggle.sh
</code></pre></div> </div> </li> </ol> <p>这样效果就是：</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">SUPER + W</code></p> <ul> <li> <p>如果微信没开 → 启动微信</p> </li> <li> <p>如果微信在后台 → 切换到前台</p> </li> <li> <p>如果微信已在前台 → 隐藏到一个 <code class="language-plaintext highlighter-rouge">special:hidden</code> 的 workspace</p> </li> </ul> </li> </ul> <h2 id="-改进后的-toggle-脚本支持跨-workspace">🔹 改进后的 toggle 脚本（支持跨 workspace）</h2> <p>保存为 <code class="language-plaintext highlighter-rouge">~/scripts/toggle-app.sh</code>：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">APP</span><span class="o">=</span><span class="nv">$1</span>

<span class="c"># 检查程序是否运行</span>
<span class="k">if</span> <span class="o">!</span> pgrep <span class="nt">-x</span> <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="o">&gt;</span>/dev/null<span class="p">;</span> <span class="k">then</span>
    <span class="nv">$APP</span> &amp;
    <span class="nb">exit </span>0
<span class="k">fi</span>

<span class="c"># 查找窗口信息</span>
<span class="nv">WIN_INFO</span><span class="o">=</span><span class="si">$(</span>hyprctl clients | <span class="nb">awk</span> <span class="nt">-v</span> <span class="nv">app</span><span class="o">=</span><span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="s1">'
    BEGIN {IGNORECASE=1}
    /class:/ {cls=$2}
    /workspace:/ {ws=$2}
    /address:/ {addr=$2}
    /focused:/ {f=$2}
    {
      if (tolower(cls)==tolower(app)) {
        print cls, ws, addr, f
      }
    }'</span><span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$WIN_INFO</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">$APP</span> &amp;
    <span class="nb">exit </span>0
<span class="k">fi</span>

<span class="c"># 解析结果（取第一个匹配窗口）</span>
<span class="nb">read </span>CLS WS ADDR FOCUSED <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$WIN_INFO</span><span class="s2">"</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$FOCUSED</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"yes"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="c"># 如果已聚焦 → 隐藏到 special:hidden</span>
    hyprctl dispatch movetoworkspacesilent special:hidden <span class="s2">"class:^(?i)</span><span class="nv">$APP</span><span class="s2">$"</span>
<span class="k">else
    if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$WS</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"</span><span class="si">$(</span>hyprctl activeworkspace <span class="nt">-j</span> | jq <span class="nt">-r</span> .id<span class="si">)</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        <span class="c"># 如果在其他 workspace → 切过去</span>
        hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$WS</span><span class="s2">"</span>
    <span class="k">fi</span>
    <span class="c"># 聚焦窗口</span>
    hyprctl dispatch focuswindow <span class="s2">"class:^(?i)</span><span class="nv">$APP</span><span class="s2">$"</span>
<span class="k">fi</span>

</code></pre></div></div> <h2 id="-使用方式">🔹 使用方式</h2> <ol> <li>给执行权限： <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x ~/scripts/toggle-app.sh
</code></pre></div> </div> </li> <li>在 ~/.config/hypr/hyprland.conf 里配置： <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">bind</span> <span class="o">=</span> SUPER, W, <span class="nb">exec</span>, ~/scripts/toggle-app.sh wechat
<span class="nb">bind</span> <span class="o">=</span> SUPER, T, <span class="nb">exec</span>, ~/scripts/toggle-app.sh telegram-desktop
<span class="nb">bind</span> <span class="o">=</span> SUPER, B, <span class="nb">exec</span>, ~/scripts/toggle-app.sh firefox
<span class="nb">bind</span> <span class="o">=</span> SUPER, Return, <span class="nb">exec</span>, ~/scripts/toggle-app.sh kitty
</code></pre></div> </div> </li> </ol> <h2 id="-效果">🔹 效果</h2> <ul> <li> <p>如果没运行 → 启动</p> </li> <li> <p>如果在当前 workspace → 聚焦或隐藏</p> </li> <li> <p>如果在其他 workspace → 自动切换到对应 workspace 并聚焦</p> </li> <li> <p>再按一次 → 隐藏到 <code class="language-plaintext highlighter-rouge">special:hidden</code></p> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$(hyprctl clients | awk -v app="wechat" '
    BEGIN {IGNORECASE=1}
    /class:/ {cls=$2}
    /workspace:/ {ws=$2}
    /address:/ {addr=$2}
    /focused:/ {f=$2}
    {
      if (tolower(cls)==tolower(app)) {
        print cls, ws, addr, f
      }
    }')
    
    
    hyprctl clients -j | jq -r --arg app "wechat" '
    .[] | select(.class | ascii_downcase == ($app | ascii_downcase)) 
    | "\(.class) \(.workspace.id) \(.address)"' | head -n1
    
</code></pre></div></div> <p>没有focused</p> <p>啊，明白了 👍。<br/> 你在 <code class="language-plaintext highlighter-rouge">hyprctl clients</code> 里看到的输出里 <strong>没有 <code class="language-plaintext highlighter-rouge">focused:</code> 字段</strong>，这是因为 Hyprland 在不同版本里 <code class="language-plaintext highlighter-rouge">clients</code> 的输出格式变过。</p> <p>有的版本里 <code class="language-plaintext highlighter-rouge">hyprctl clients</code> 输出的是：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class: firefox
title: Mozilla Firefox
workspace: 2
address: 0x55d9e6e
at: 1920,30
...
focusHistoryID: 12

</code></pre></div></div> <p>没有 <code class="language-plaintext highlighter-rouge">focused: yes/no</code>。<br/> 要判断某个窗口是不是前台，就要<strong>对比它的 workspace 和当前活动的 workspace</strong>。</p> <h2 id="-改进版兼容没有-focused-字段的情况">🔹 改进版（兼容没有 <code class="language-plaintext highlighter-rouge">focused</code> 字段的情况）</h2> <p>更新后的 <code class="language-plaintext highlighter-rouge">toggle-app.sh</code>：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">APP</span><span class="o">=</span><span class="nv">$1</span>

<span class="c"># 检查程序是否运行</span>
<span class="k">if</span> <span class="o">!</span> pgrep <span class="nt">-x</span> <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="o">&gt;</span>/dev/null<span class="p">;</span> <span class="k">then</span>
    <span class="nv">$APP</span> &amp;
    <span class="nb">exit </span>0
<span class="k">fi</span>

<span class="c"># 当前 workspace ID</span>
<span class="nv">CUR_WS</span><span class="o">=</span><span class="si">$(</span>hyprctl activeworkspace <span class="nt">-j</span> | jq <span class="nt">-r</span> .id<span class="si">)</span>

<span class="c"># 查找第一个匹配的窗口</span>
<span class="nv">WIN_INFO</span><span class="o">=</span><span class="si">$(</span>hyprctl clients <span class="nt">-j</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> app <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="s1">'
    .[] | select(.class | ascii_downcase == ($app | ascii_downcase)) 
    | "\(.class) \(.workspace.id) \(.address)"'</span> | <span class="nb">head</span> <span class="nt">-n1</span><span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$WIN_INFO</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">$APP</span> &amp;
    <span class="nb">exit </span>0
<span class="k">fi

</span><span class="nb">read </span>CLS WS ADDR <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$WIN_INFO</span><span class="s2">"</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$WS</span><span class="s2">"</span> <span class="nt">-eq</span> <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="c"># 如果在当前 workspace → 隐藏到 special:hidden</span>
    hyprctl dispatch movetoworkspacesilent special:hidden <span class="s2">"address:</span><span class="nv">$ADDR</span><span class="s2">"</span>
<span class="k">else</span>
    <span class="c"># 如果在其他 workspace → 切换并聚焦</span>
    hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$WS</span><span class="s2">"</span>
    hyprctl dispatch focuswindow <span class="s2">"address:</span><span class="nv">$ADDR</span><span class="s2">"</span>
<span class="k">fi</span>

</code></pre></div></div> <h2 id="-关键点">🔹 关键点</h2> <ul> <li> <p>这里用 <code class="language-plaintext highlighter-rouge">hyprctl clients -j</code>（JSON 格式），再用 <code class="language-plaintext highlighter-rouge">jq</code> 解析：</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">.class</code> → 应用类名</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">.workspace.id</code> → 窗口所在的 workspace</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">.address</code> → 窗口地址（唯一 ID）</p> </li> </ul> </li> <li> <p>判断逻辑改成：</p> <ul> <li> <p><strong>在当前 workspace</strong> → 隐藏到 <code class="language-plaintext highlighter-rouge">special:hidden</code></p> </li> <li> <p><strong>在其他 workspace</strong> → 切换过去并聚焦</p> </li> </ul> </li> </ul> <h2 id="-配置方式">🔹 配置方式</h2> <p>同样在 <code class="language-plaintext highlighter-rouge">hyprland.conf</code> 里写：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">bind</span> <span class="o">=</span> SUPER, W, <span class="nb">exec</span>, ~/scripts/toggle-app.sh wechat
<span class="nb">bind</span> <span class="o">=</span> SUPER, T, <span class="nb">exec</span>, ~/scripts/toggle-app.sh telegram-desktop
<span class="nb">bind</span> <span class="o">=</span> SUPER, B, <span class="nb">exec</span>, ~/scripts/toggle-app.sh firefox

</code></pre></div></div> <p>这样就不会依赖 <code class="language-plaintext highlighter-rouge">focused</code> 字段了 ✅。</p> <hr/> <p>隐藏后再打开 不平铺窗口</p> <p>👌 你说的情况是：<br/> 脚本里把窗口 <strong>移到 <code class="language-plaintext highlighter-rouge">special:hidden</code></strong> workspace 之后，再切回来时，窗口不是平铺状态了（比如变成浮动、尺寸乱掉）。</p> <p>这是因为：</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">special:hidden</code> 本身是一个 <strong>特殊 workspace</strong>，窗口切进去切出来时，Hyprland 可能会改变它的 <strong>tiling/floating 状态</strong>。</p> </li> <li> <p>另外，<code class="language-plaintext highlighter-rouge">hyprctl dispatch movetoworkspacesilent</code> 没有强制保持 tiling。</p> </li> </ul> <h2 id="-解决思路">🔹 解决思路</h2> <ol> <li> <p><strong>记录窗口原本的状态</strong>（tiling/floating）。</p> </li> <li> <p>隐藏时 → 移到 <code class="language-plaintext highlighter-rouge">special:hidden</code>。</p> </li> <li> <p>再显示时 → 把它移回原来的 workspace，并恢复 tiling 状态。</p> </li> </ol> <h2 id="-改进脚本保证窗口恢复平铺">🔹 改进脚本：保证窗口恢复平铺</h2> <p>保存为 <code class="language-plaintext highlighter-rouge">~/scripts/toggle-app.sh</code>：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">APP</span><span class="o">=</span><span class="nv">$1</span>

<span class="nv">STATE_FILE</span><span class="o">=</span><span class="s2">"/tmp/hypr_toggle_</span><span class="k">${</span><span class="nv">APP</span><span class="k">}</span><span class="s2">.state"</span>

<span class="c"># 检查程序是否运行</span>
<span class="k">if</span> <span class="o">!</span> pgrep <span class="nt">-x</span> <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="o">&gt;</span>/dev/null<span class="p">;</span> <span class="k">then</span>
    <span class="nv">$APP</span> &amp;
    <span class="nb">exit </span>0
<span class="k">fi

</span><span class="nv">CUR_WS</span><span class="o">=</span><span class="si">$(</span>hyprctl activeworkspace <span class="nt">-j</span> | jq <span class="nt">-r</span> .id<span class="si">)</span>

<span class="c"># 找窗口信息</span>
<span class="nv">WIN_INFO</span><span class="o">=</span><span class="si">$(</span>hyprctl clients <span class="nt">-j</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> app <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="s1">'
    .[] | select(.class | ascii_downcase == ($app | ascii_downcase))
    | "\(.workspace.id) \(.address) \(.floating)"'</span> | <span class="nb">head</span> <span class="nt">-n1</span><span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$WIN_INFO</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">$APP</span> &amp;
    <span class="nb">exit </span>0
<span class="k">fi

</span><span class="nb">read </span>WS ADDR FLOATING <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$WIN_INFO</span><span class="s2">"</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$WS</span><span class="s2">"</span> <span class="nt">-eq</span> <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="c"># 已在当前 workspace → 隐藏</span>
    <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2"> </span><span class="nv">$FLOATING</span><span class="s2">"</span> <span class="o">&gt;</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span>
    hyprctl dispatch movetoworkspacesilent special:hidden <span class="s2">"address:</span><span class="nv">$ADDR</span><span class="s2">"</span>
<span class="k">else
    if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$WS</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"special:hidden"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        <span class="c"># 从隐藏恢复 → 移回原 workspace</span>
        <span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
            </span><span class="nb">read </span>OLD_WS OLD_FLOATING &lt; <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span>
            hyprctl dispatch movetoworkspacesilent <span class="s2">"</span><span class="nv">$OLD_WS</span><span class="s2">"</span> <span class="s2">"address:</span><span class="nv">$ADDR</span><span class="s2">"</span>
            <span class="c"># 恢复 tiling 状态</span>
            <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$OLD_FLOATING</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"false"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
                </span>hyprctl dispatch toggletiling <span class="s2">"address:</span><span class="nv">$ADDR</span><span class="s2">"</span>
            <span class="k">fi
            </span><span class="nb">rm</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span>
        <span class="k">else
            </span>hyprctl dispatch movetoworkspacesilent <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span> <span class="s2">"address:</span><span class="nv">$ADDR</span><span class="s2">"</span>
        <span class="k">fi
    else</span>
        <span class="c"># 在其他 workspace → 切过去并聚焦</span>
        hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$WS</span><span class="s2">"</span>
        hyprctl dispatch focuswindow <span class="s2">"address:</span><span class="nv">$ADDR</span><span class="s2">"</span>
    <span class="k">fi
fi</span>

</code></pre></div></div> <h2 id="-逻辑说明">🔹 逻辑说明</h2> <ul> <li> <p>第一次隐藏时 → 把 <strong>原 workspace + 是否浮动</strong> 写到 <code class="language-plaintext highlighter-rouge">/tmp/hypr_toggle_APP.state</code>。</p> </li> <li> <p>再次切换时 → 如果窗口在 <code class="language-plaintext highlighter-rouge">special:hidden</code>，就：</p> <ol> <li> <p>移回原 workspace</p> </li> <li> <p>如果之前是 tiling → 强制 <code class="language-plaintext highlighter-rouge">toggletiling</code>，保证不是浮动。</p> </li> </ol> </li> </ul> <p>这样你就能做到：</p> <ul> <li> <p><strong>按快捷键 → 隐藏</strong>（移到 hidden）</p> </li> <li> <p><strong>再按一次 → 恢复到原 workspace，并保持平铺</strong></p> </li> </ul> <p>++++++++++++++++++++++++++++++++++++++++++++++++++++</p> <p>这样改都不能隐藏了</p> <p>Thought for 1m 13s</p> <p>好——没关系，我们一步步把它修好。你说“这样改都不能隐藏了”，<strong>最常见的原因</strong>有两条，我先把原因说清楚再给你一个实战可用的脚本（含调试日志、回退策略），你直接替换试一下：</p> <p>原因总结（简短）</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">movetoworkspacesilent</code> + <code class="language-plaintext highlighter-rouge">special</code> 的组合在不同 Hyprland 版本/实现上行为不稳定或未完全支持，社区里有相关 report（所以直接用 <code class="language-plaintext highlighter-rouge">movetoworkspacesilent "special,..."</code> 可能没作用）。<a href="https://github.com/hyprwm/Hyprland/issues/1452?utm_source=chatgpt.com">GitHub</a></p> </li> <li> <p>Special workspace 本身有一些限制（例如 special 的浮动/tiling 行为和普通 workspace 不完全一样），window 在 special 与恢复时状态会被 compositor 改变。文档也指出 special 的行为与普通 workspace 不同。<a href="https://wiki.hypr.land/0.18.0beta/Configuring/Dispatchers/?utm_source=chatgpt.com">Hyprland Wiki</a></p> </li> </ul> <p>因此我们要做两件事：</p> <ol> <li> <p>把隐藏逻辑做得更<strong>稳健</strong>（先尝试最优 API，失败就降级到可靠的 workaround）；</p> </li> <li> <p>回显（恢复）时<strong>明确用 <code class="language-plaintext highlighter-rouge">address:</code> 指定窗口</strong>并在必要时做二次恢复（防止被动成浮动）。</p> </li> </ol> <h1 id="推荐脚本带调试--回退">推荐脚本（带调试 + 回退）</h1> <p>把下面保存为 <code class="language-plaintext highlighter-rouge">~/scripts/wechat-toggle.sh</code>（或你原来的脚本名），并 <code class="language-plaintext highlighter-rouge">chmod +x</code>。这个脚本会记录日志 <code class="language-plaintext highlighter-rouge">/tmp/hypr_toggle_debug.log</code>，并尝试多种方式来隐藏/恢复（先试 silent，失败就用 movetoworkspace+切回 的 fallback）：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>
<span class="nb">set</span> <span class="nt">-euo</span> pipefail
<span class="nv">APP</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
<span class="nv">STATE_DIR</span><span class="o">=</span><span class="s2">"/tmp/hypr_toggle_states"</span>
<span class="nv">LOG</span><span class="o">=</span><span class="s2">"/tmp/hypr_toggle_debug.log"</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$STATE_DIR</span><span class="s2">"</span>
: <span class="o">&gt;</span><span class="s2">"</span><span class="nv">$LOG</span><span class="s2">"</span>

dbg<span class="o">(){</span> <span class="nb">echo</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">date</span> +%T<span class="si">)</span><span class="s2"> </span><span class="nv">$*</span><span class="s2">"</span> <span class="o">&gt;&gt;</span><span class="s2">"</span><span class="nv">$LOG</span><span class="s2">"</span><span class="p">;</span> <span class="o">}</span>

<span class="c"># find first matching window's address</span>
<span class="nv">WIN_JSON</span><span class="o">=</span><span class="si">$(</span>hyprctl clients <span class="nt">-j</span> 2&gt;/dev/null <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"[]"</span><span class="si">)</span>
<span class="nv">ADDR</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_JSON</span><span class="s2">"</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> app <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="s1">'
  .[] | select((.class // "" | ascii_downcase) == ($app|ascii_downcase)) | .address'</span> | <span class="nb">head</span> <span class="nt">-n1</span> <span class="o">||</span> <span class="nb">true</span><span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="o">]</span> <span class="o">||</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"null"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span>dbg <span class="s2">"No running window for '</span><span class="nv">$APP</span><span class="s2">' found. Starting it."</span>
  <span class="c"># 修改为你的启动命令（如果可执行名不同）</span>
  <span class="nv">$APP</span> &amp; <span class="nb">disown
  exit </span>0
<span class="k">fi</span>

<span class="c"># workspace ids and names</span>
<span class="nv">WIN_WS</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_JSON</span><span class="s2">"</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> addr <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="s1">'.[] | select(.address==$addr) | (.workspace.id // "-1")'</span> <span class="si">)</span>
<span class="nv">WIN_WS_NAME</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_JSON</span><span class="s2">"</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> addr <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="s1">'.[] | select(.address==$addr) | (.workspace.name // "")'</span> <span class="si">)</span>
<span class="nv">CUR_WS</span><span class="o">=</span><span class="si">$(</span>hyprctl activeworkspace <span class="nt">-j</span> | jq <span class="nt">-r</span> .id<span class="si">)</span>

dbg <span class="s2">"Found </span><span class="nv">$APP</span><span class="s2"> addr=</span><span class="nv">$ADDR</span><span class="s2"> ws=</span><span class="nv">$WIN_WS</span><span class="s2"> ws_name='</span><span class="nv">$WIN_WS_NAME</span><span class="s2">' cur_ws=</span><span class="nv">$CUR_WS</span><span class="s2">"</span>

<span class="nv">STATE_FILE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$STATE_DIR</span><span class="s2">/</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">.state"</span>

<span class="c"># Helper to re-query where the window is now</span>
where_is<span class="o">()</span> <span class="o">{</span>
  hyprctl clients <span class="nt">-j</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> addr <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="s1">'.[] | select(.address==$addr) | (.workspace.id // "-1")'</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"-1"</span>
<span class="o">}</span>

<span class="c"># 1) 如果窗口在当前 workspace -&gt; 隐藏（move to special）</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$WIN_WS</span><span class="s2">"</span> <span class="nt">-eq</span> <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span>dbg <span class="s2">"Attempting to hide (current ws)"</span>
  <span class="c"># 保存原 workspace 到状态文件，便于恢复</span>
  <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span> <span class="o">&gt;</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span>

  <span class="c"># 尝试 1: movetoworkspacesilent special,address:ADDR （优雅但可能不支持 special）</span>
  <span class="k">if </span>hyprctl dispatch movetoworkspacesilent <span class="s2">"special,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then
    </span><span class="nb">sleep </span>0.05
    <span class="nv">NEWWS</span><span class="o">=</span><span class="si">$(</span>where_is<span class="si">)</span>
    <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$NEWWS</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
      </span>dbg <span class="s2">"Hidden via movetoworkspacesilent to ws=</span><span class="nv">$NEWWS</span><span class="s2">"</span>
      <span class="nb">exit </span>0
    <span class="k">fi
    </span>dbg <span class="s2">"movetoworkspacesilent didn't move the window (no-op)."</span>
  <span class="k">else
    </span>dbg <span class="s2">"movetoworkspacesilent returned non-zero or errored."</span>
  <span class="k">fi</span>

  <span class="c"># 回退方案（可靠）：movetoworkspace special (会切到 special)，再切回原 workspace</span>
  dbg <span class="s2">"Fallback: movetoworkspace special + switch back to </span><span class="nv">$CUR_WS</span><span class="s2">"</span>
  hyprctl dispatch movetoworkspace <span class="s2">"special,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span>
  <span class="c"># 切回之前的 workspace（这样用户感觉没有切换到 special）</span>
  hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span>
  <span class="nb">sleep </span>0.05
  <span class="nv">NEWWS</span><span class="o">=</span><span class="si">$(</span>where_is<span class="si">)</span>
  dbg <span class="s2">"After fallback, window ws=</span><span class="nv">$NEWWS</span><span class="s2">"</span>
  <span class="nb">exit </span>0
<span class="k">fi</span>

<span class="c"># 2) 如果窗口不在当前 workspace</span>
<span class="c"># 检查是否在 special（判断 workspace 名或特殊 id）</span>
<span class="nv">IS_SPECIAL</span><span class="o">=</span><span class="nb">false</span>
<span class="c"># 有些 hyprctl 版本会在 .workspace.name / .workspace.special 提供信息；我们尽量容错判断</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$WIN_WS</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"-1"</span> <span class="o">]</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_WS_NAME</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-qi</span> <span class="s2">"special"</span><span class="p">;</span> <span class="k">then
  </span><span class="nv">IS_SPECIAL</span><span class="o">=</span><span class="nb">true
</span><span class="k">fi

if</span> <span class="nv">$IS_SPECIAL</span><span class="p">;</span> <span class="k">then
  </span>dbg <span class="s2">"Window appears to be in special workspace -&gt; restoring"</span>

  <span class="c"># 读取之前保存的原 workspace（没有就用当前）</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nv">OLD_WS</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span><span class="si">)</span>
  <span class="k">else
    </span><span class="nv">OLD_WS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span>
  <span class="k">fi

  </span>dbg <span class="s2">"Trying movetoworkspacesilent back to </span><span class="nv">$OLD_WS</span><span class="s2">"</span>
  <span class="k">if </span>hyprctl dispatch movetoworkspacesilent <span class="s2">"</span><span class="k">${</span><span class="nv">OLD_WS</span><span class="k">}</span><span class="s2">,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then
    </span><span class="nb">sleep </span>0.05
    hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$OLD_WS</span><span class="s2">"</span>
    hyprctl dispatch focuswindow <span class="s2">"address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span>
    <span class="nb">rm</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span>
    dbg <span class="s2">"Restored via movetoworkspacesilent to </span><span class="nv">$OLD_WS</span><span class="s2">"</span>
    <span class="nb">exit </span>0
  <span class="k">fi

  </span>dbg <span class="s2">"Fallback restore: toggling special/showing + movetoworkspace back"</span>
  <span class="c"># best-effort fallback: show special, then move the window back (some versions require non-silent)</span>
  hyprctl dispatch togglespecialworkspace __TEMP <span class="o">||</span> <span class="nb">true
  </span>hyprctl dispatch togglespecialworkspace __TEMP <span class="o">||</span> <span class="nb">true
  </span>hyprctl dispatch movetoworkspace <span class="s2">"</span><span class="k">${</span><span class="nv">OLD_WS</span><span class="k">}</span><span class="s2">,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span> <span class="o">||</span> <span class="nb">true
  </span>hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$OLD_WS</span><span class="s2">"</span>
  hyprctl dispatch focuswindow <span class="s2">"address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span> <span class="o">||</span> <span class="nb">true
  rm</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span>
  dbg <span class="s2">"Fallback restore attempted."</span>
  <span class="nb">exit </span>0
<span class="k">fi</span>

<span class="c"># 最后：窗口在别的普通 workspace -&gt; 直接切过去并 focus</span>
dbg <span class="s2">"Window in other workspace (</span><span class="nv">$WIN_WS</span><span class="s2">) -&gt; switch and focus"</span>
hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$WIN_WS</span><span class="s2">"</span>
hyprctl dispatch focuswindow <span class="s2">"address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">exit </span>0

</code></pre></div></div> <h1 id="你要做的快速">你要做的（快速）</h1> <ol> <li> <p>把脚本保存并 <code class="language-plaintext highlighter-rouge">chmod +x ~/scripts/wechat-toggle.sh</code>。</p> </li> <li> <p>在 <code class="language-plaintext highlighter-rouge">hyprland.conf</code> 里绑定（例）： ``` bind = SUPER, W, exec, ~/scripts/wechat-toggle.sh wechat</p> </li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
3. 触发一次隐藏和恢复，若**还不能隐藏**，把这两个命令的输出贴上来（我直接看日志和状态）：
```shell
cat /tmp/hypr_toggle_debug.log
hyprctl clients -j | jq '.[] | {class: .class, address: .address, ws: .workspace.id, name: .workspace.name, floating: .floating}'
hyprctl activeworkspace -j

</code></pre></div></div> <p>（把输出直接复制粘贴到聊天窗口就行）</p> <h1 id="其他注意点常见坑">其他注意点（常见坑）</h1> <ul> <li> <p><code class="language-plaintext highlighter-rouge">jq</code> 必须安装；脚本用了 <code class="language-plaintext highlighter-rouge">hyprctl clients -j</code> 的 JSON 输出来精确定位窗口。</p> </li> <li> <p>有些 Hyprland 版本对 <code class="language-plaintext highlighter-rouge">movetoworkspacesilent</code>（尤其跟 special 配合）行为不一致；脚本里做了回退（先试 silent，再用 movetoworkspace + 切回）。文档和 issue 都有相关提到。<a href="https://wiki.hypr.land/0.18.0beta/Configuring/Dispatchers/?utm_source=chatgpt.com">Hyprland Wiki+1</a></p> </li> <li> <p>special workspace 对浮动/tiling 的处理有特别规则（可能导致窗口在 special 里不能是浮动），因此恢复时需要明确 <code class="language-plaintext highlighter-rouge">movetoworkspace &lt;ws&gt;,address:...</code> 或者 focus 后用 <code class="language-plaintext highlighter-rouge">settiled</code>/<code class="language-plaintext highlighter-rouge">setfloating</code>（这些 dispatcher 在你的 hyprland 版本里是否可用请检查）</p> </li> </ul> <p>先把上面的脚本跑一下，然后把 <code class="language-plaintext highlighter-rouge">/tmp/hypr_toggle_debug.log</code> 和 <code class="language-plaintext highlighter-rouge">hyprctl clients -j | jq ...</code> 的输出贴上来。我会基于真实输出做针对性修正（通常问题就是 “movetoworkspacesilent + special 不生效” 或 “window spec 没写成 address:…” 两类之一）。</p> <p>+++++++++++++++++++++++++++++++++++++++++++++++++</p> <p>现在可以了</p> <h6 id="chatgpt-said">ChatGPT said:</h6> <p>太好了 🎉！那就说明之前的问题确实是 Hyprland 的 <code class="language-plaintext highlighter-rouge">special</code> + <code class="language-plaintext highlighter-rouge">movetoworkspacesilent</code> 行为不一致导致的，现在用带回退逻辑的脚本就稳住了。</p> <p>总结一下你现在的方案：</p> <ul> <li> <p><strong>隐藏</strong>：窗口从当前 workspace 移到 <code class="language-plaintext highlighter-rouge">special</code>，同时保持你原本的 workspace 不切换。</p> </li> <li> <p><strong>恢复</strong>：根据保存的状态把窗口移回原 workspace，并自动聚焦。</p> </li> <li> <p><strong>可靠性</strong>：加了回退逻辑，就算某些 Hyprland 版本对 <code class="language-plaintext highlighter-rouge">movetoworkspacesilent special,...</code> 不支持，也能靠 fallback 正常工作。</p> </li> </ul> <p>要不要我再帮你整理一个更<strong>精简版</strong>的脚本（去掉 debug 和多余分支，方便长期使用），还是保留现在这个带日志的版本（方便以后出问题时排查）？</p> <p>好的</p> <p>👌 那我帮你整理一个 <strong>精简稳定版</strong> 脚本，保留核心逻辑，把调试日志去掉，方便日常使用。</p> <p>保存为 <code class="language-plaintext highlighter-rouge">~/scripts/toggle-app.sh</code> 并 <code class="language-plaintext highlighter-rouge">chmod +x</code>：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>
<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="nv">APP</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
<span class="nv">STATE_DIR</span><span class="o">=</span><span class="s2">"/tmp/hypr_toggle_states"</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$STATE_DIR</span><span class="s2">"</span>

<span class="c"># 找到第一个匹配窗口</span>
<span class="nv">WIN_JSON</span><span class="o">=</span><span class="si">$(</span>hyprctl clients <span class="nt">-j</span><span class="si">)</span>
<span class="nv">ADDR</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_JSON</span><span class="s2">"</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> app <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="s1">'
  .[] | select((.class // "" | ascii_downcase) == ($app|ascii_downcase)) | .address'</span> | <span class="nb">head</span> <span class="nt">-n1</span><span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="o">]</span> <span class="o">||</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"null"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="c"># 没找到就启动应用（按需改为你的启动命令）</span>
  <span class="nv">$APP</span> &amp; <span class="nb">disown
  exit </span>0
<span class="k">fi

</span><span class="nv">WIN_WS</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_JSON</span><span class="s2">"</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> addr <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="s1">'.[] | select(.address==$addr) | .workspace.id'</span><span class="si">)</span>
<span class="nv">CUR_WS</span><span class="o">=</span><span class="si">$(</span>hyprctl activeworkspace <span class="nt">-j</span> | jq <span class="nt">-r</span> .id<span class="si">)</span>
<span class="nv">STATE_FILE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$STATE_DIR</span><span class="s2">/</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">.state"</span>

<span class="c"># helper: 确认窗口现在在哪个 workspace</span>
where_is<span class="o">()</span> <span class="o">{</span>
  hyprctl clients <span class="nt">-j</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> addr <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="s1">'.[] | select(.address==$addr) | (.workspace.id // "-1")'</span>
<span class="o">}</span>

<span class="c"># 如果窗口在当前 workspace -&gt; 隐藏</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$WIN_WS</span><span class="s2">"</span> <span class="nt">-eq</span> <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span> <span class="o">&gt;</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span>

  <span class="c"># 优先 silent 方法</span>
  <span class="k">if </span>hyprctl dispatch movetoworkspacesilent <span class="s2">"special,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then
    </span><span class="nb">exit </span>0
  <span class="k">fi</span>

  <span class="c"># 回退：movetoworkspace special，然后切回原 ws</span>
  hyprctl dispatch movetoworkspace <span class="s2">"special,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span>
  hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span>
  <span class="nb">exit </span>0
<span class="k">fi</span>

<span class="c"># 如果窗口在 special -&gt; 恢复</span>
<span class="nv">WIN_WS_NAME</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_JSON</span><span class="s2">"</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> addr <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="s1">'.[] | select(.address==$addr) | (.workspace.name // "")'</span><span class="si">)</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$WIN_WS</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"-1"</span> <span class="o">]</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_WS_NAME</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-qi</span> <span class="s2">"special"</span><span class="p">;</span> <span class="k">then
  </span><span class="nv">OLD_WS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span>
  <span class="o">[</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nv">OLD_WS</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span><span class="si">)</span>

  hyprctl dispatch movetoworkspacesilent <span class="s2">"</span><span class="k">${</span><span class="nv">OLD_WS</span><span class="k">}</span><span class="s2">,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span> <span class="o">||</span> <span class="se">\</span>
    hyprctl dispatch movetoworkspace <span class="s2">"</span><span class="k">${</span><span class="nv">OLD_WS</span><span class="k">}</span><span class="s2">,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span>

  hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$OLD_WS</span><span class="s2">"</span>
  hyprctl dispatch focuswindow <span class="s2">"address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span>
  <span class="nb">rm</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span>
  <span class="nb">exit </span>0
<span class="k">fi</span>

<span class="c"># 否则：窗口在别的 workspace -&gt; 切过去并聚焦</span>
hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$WIN_WS</span><span class="s2">"</span>
hyprctl dispatch focuswindow <span class="s2">"address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">exit </span>0

</code></pre></div></div> <h3 id="使用方法-1">使用方法</h3> <ol> <li>保存并赋权： <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x ~/scripts/toggle-app.sh
</code></pre></div> </div> </li> <li>Hyprland 配置里加绑定，例如微信： <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">bind</span> <span class="o">=</span> SUPER, W, <span class="nb">exec</span>, ~/scripts/toggle-app.sh wechat
</code></pre></div> </div> </li> </ol> <p>（<code class="language-plaintext highlighter-rouge">wechat</code> 要和 <code class="language-plaintext highlighter-rouge">hyprctl clients -j</code> 里 <code class="language-plaintext highlighter-rouge">.class</code> 名一致，比如 <code class="language-plaintext highlighter-rouge">WeChat.exe</code>，可以调一下）</p> <p>这样就是一个干净的「一键隐藏/恢复/启动」脚本了。</p> <p>要不要我再帮你写一个 <strong>通用版本</strong>，支持多个 app（比如 SUPER+F 打开/隐藏 Firefox，SUPER+T 打开/隐藏 Telegram），只用一个脚本就够？</p> <p>好的</p> <p>👌 那我给你整理一个 <strong>通用多应用版本</strong>，只用一个脚本就能管理多个应用的「启动 → 隐藏 → 恢复」逻辑。</p> <p>脚本：<code class="language-plaintext highlighter-rouge">~/scripts/toggle-app.sh</code></p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>
<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="nv">STATE_DIR</span><span class="o">=</span><span class="s2">"/tmp/hypr_toggle_states"</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$STATE_DIR</span><span class="s2">"</span>

<span class="nv">APP</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>   <span class="c"># 第一个参数是应用名，比如 wechat/firefox/telegram</span>
<span class="nv">CMD</span><span class="o">=</span><span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span>   <span class="c"># 第二个参数是启动命令，比如 wechat/firefox/telegram-desktop</span>

<span class="c"># 找窗口</span>
<span class="nv">WIN_JSON</span><span class="o">=</span><span class="si">$(</span>hyprctl clients <span class="nt">-j</span><span class="si">)</span>
<span class="nv">ADDR</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_JSON</span><span class="s2">"</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> app <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="s1">'
  .[] | select((.class // "" | ascii_downcase) == ($app|ascii_downcase)) | .address'</span> | <span class="nb">head</span> <span class="nt">-n1</span><span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="o">]</span> <span class="o">||</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"null"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="c"># 没找到窗口就启动</span>
  <span class="nb">eval</span> <span class="s2">"</span><span class="nv">$CMD</span><span class="s2"> &amp; disown"</span>
  <span class="nb">exit </span>0
<span class="k">fi

</span><span class="nv">WIN_WS</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_JSON</span><span class="s2">"</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> addr <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="s1">'.[] | select(.address==$addr) | .workspace.id'</span><span class="si">)</span>
<span class="nv">CUR_WS</span><span class="o">=</span><span class="si">$(</span>hyprctl activeworkspace <span class="nt">-j</span> | jq <span class="nt">-r</span> .id<span class="si">)</span>
<span class="nv">STATE_FILE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$STATE_DIR</span><span class="s2">/</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">.state"</span>

<span class="c"># Helper: 确认窗口在哪个 workspace</span>
where_is<span class="o">()</span> <span class="o">{</span>
  hyprctl clients <span class="nt">-j</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> addr <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="s1">'.[] | select(.address==$addr) | (.workspace.id // "-1")'</span>
<span class="o">}</span>

<span class="c"># 如果窗口在当前 workspace -&gt; 隐藏</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$WIN_WS</span><span class="s2">"</span> <span class="nt">-eq</span> <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span> <span class="o">&gt;</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span>

  <span class="k">if </span>hyprctl dispatch movetoworkspacesilent <span class="s2">"special,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then
    </span><span class="nb">exit </span>0
  <span class="k">fi

  </span>hyprctl dispatch movetoworkspace <span class="s2">"special,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span>
  hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span>
  <span class="nb">exit </span>0
<span class="k">fi</span>

<span class="c"># 如果窗口在 special -&gt; 恢复</span>
<span class="nv">WIN_WS_NAME</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_JSON</span><span class="s2">"</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> addr <span class="s2">"</span><span class="nv">$ADDR</span><span class="s2">"</span> <span class="s1">'.[] | select(.address==$addr) | (.workspace.name // "")'</span><span class="si">)</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$WIN_WS</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"-1"</span> <span class="o">]</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$WIN_WS_NAME</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-qi</span> <span class="s2">"special"</span><span class="p">;</span> <span class="k">then
  </span><span class="nv">OLD_WS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CUR_WS</span><span class="s2">"</span>
  <span class="o">[</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nv">OLD_WS</span><span class="o">=</span><span class="si">$(</span><span class="nb">cat</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span><span class="si">)</span>

  hyprctl dispatch movetoworkspacesilent <span class="s2">"</span><span class="k">${</span><span class="nv">OLD_WS</span><span class="k">}</span><span class="s2">,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span> <span class="o">||</span> <span class="se">\</span>
    hyprctl dispatch movetoworkspace <span class="s2">"</span><span class="k">${</span><span class="nv">OLD_WS</span><span class="k">}</span><span class="s2">,address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span>

  hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$OLD_WS</span><span class="s2">"</span>
  hyprctl dispatch focuswindow <span class="s2">"address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span>
  <span class="nb">rm</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$STATE_FILE</span><span class="s2">"</span>
  <span class="nb">exit </span>0
<span class="k">fi</span>

<span class="c"># 窗口在别的 workspace -&gt; 切过去并聚焦</span>
hyprctl dispatch workspace <span class="s2">"</span><span class="nv">$WIN_WS</span><span class="s2">"</span>
hyprctl dispatch focuswindow <span class="s2">"address:</span><span class="k">${</span><span class="nv">ADDR</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">exit </span>0

</code></pre></div></div> <h2 id="用法示例">用法示例</h2> <p>假设你要给微信 / Firefox / Telegram 设置快捷键：</p> <h3 id="hyprland-配置">Hyprland 配置</h3> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># SUPER+W -&gt; 微信</span>
<span class="nb">bind</span> <span class="o">=</span> SUPER, W, <span class="nb">exec</span>, ~/scripts/toggle-app.sh wechat <span class="s2">"wechat"</span>

<span class="c"># SUPER+F -&gt; Firefox</span>
<span class="nb">bind</span> <span class="o">=</span> SUPER, F, <span class="nb">exec</span>, ~/scripts/toggle-app.sh firefox <span class="s2">"firefox"</span>

<span class="c"># SUPER+T -&gt; Telegram</span>
<span class="nb">bind</span> <span class="o">=</span> SUPER, T, <span class="nb">exec</span>, ~/scripts/toggle-app.sh telegram <span class="s2">"telegram-desktop"</span>

</code></pre></div></div> <h2 id="说明">说明</h2> <ul> <li> <p>第一个参数 <code class="language-plaintext highlighter-rouge">$1</code> 用来匹配窗口的 <strong>class 名</strong>（通过 <code class="language-plaintext highlighter-rouge">hyprctl clients -j | jq '.[].class'</code> 查看实际值）。</p> </li> <li> <p>第二个参数 <code class="language-plaintext highlighter-rouge">$2</code> 是应用的启动命令。</p> </li> <li> <p>这样一个脚本就能管理多个应用，配置文件里只需要传不同参数即可。</p> </li> <li> <p>如果你有 Wine/Deepin 的微信，可以写成：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">bind</span> <span class="o">=</span> SUPER, W, <span class="nb">exec</span>, ~/scripts/toggle-app.sh wechat <span class="s2">"/opt/deepinwine/apps/Deepin-WeChat/wechat"</span>
</code></pre></div> </div> </li> </ul> <p>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p> <p>要不要我帮你写一个 <strong>自动配置检测工具</strong>，比如输入应用名就能输出它的 class 和你需要写在绑定里的命令？这样可以快速调试微信这种特殊的 Wine 应用。</p> <p>好的</p> <p>👌 那我帮你写一个 <strong>自动检测工具</strong>，可以快速找出某个应用窗口的 <code class="language-plaintext highlighter-rouge">class</code> 和启动命令，方便配置到脚本里。</p> <p>脚本：<code class="language-plaintext highlighter-rouge">~/scripts/find-app-class.sh</code></p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>
<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="nv">APP</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">1</span><span class="k">:-}</span><span class="s2">"</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"用法: </span><span class="nv">$0</span><span class="s2"> &lt;关键字&gt;"</span>
  <span class="nb">echo</span> <span class="s2">"例如: </span><span class="nv">$0</span><span class="s2"> wechat"</span>
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">"正在查找包含 '</span><span class="nv">$APP</span><span class="s2">' 的窗口..."</span>

hyprctl clients <span class="nt">-j</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> app <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="s1">'
  .[]
  | select(
      (.class // "" | ascii_downcase | contains($app|ascii_downcase))
      or
      (.title // "" | ascii_downcase | contains($app|ascii_downcase))
    )
  | "class=\(.class)  title=\(.title)  address=\(.address)  ws=\(.workspace.id)"'</span>

</code></pre></div></div> <h2 id="用法">用法</h2> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x ~/scripts/find-app-class.sh
~/scripts/find-app-class.sh wechat

</code></pre></div></div> <p>输出示例（不同应用会不一样）：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">class</span><span class="o">=</span>WeChat.exe  <span class="nv">title</span><span class="o">=</span>微信  <span class="nv">address</span><span class="o">=</span>0x55a6f3b  <span class="nv">ws</span><span class="o">=</span>2

</code></pre></div></div> <p>这样你就知道：</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">class</code> 是 <code class="language-plaintext highlighter-rouge">WeChat.exe</code>，那么在 <code class="language-plaintext highlighter-rouge">toggle-app.sh</code> 里传参要写 <code class="language-plaintext highlighter-rouge">WeChat.exe</code>（大小写敏感！）。</p> </li> <li> <p>启动命令则是你平时运行微信的命令，比如 <code class="language-plaintext highlighter-rouge">/opt/deepinwine/apps/Deepin-WeChat/wechat</code>。</p> </li> </ul> <h2 id="配置-hyprland-绑定">配置 Hyprland 绑定</h2> <p>拿到结果后，比如你发现微信的 class 是 <code class="language-plaintext highlighter-rouge">WeChat.exe</code>，就写：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">bind</span> <span class="o">=</span> SUPER, W, <span class="nb">exec</span>, ~/scripts/toggle-app.sh WeChat.exe <span class="s2">"/opt/deepinwine/apps/Deepin-WeChat/wechat"</span>

</code></pre></div></div> <p>这样脚本才能正确匹配窗口。</p>]]></content><author><name></name></author><category term="omarchy"/><summary type="html"><![CDATA[自动检测版脚本]]></summary></entry><entry><title type="html">Hyprlan微信通知</title><link href="https://vonwind.github.io/blog/2025/Hyprlan%E5%BE%AE%E4%BF%A1%E9%80%9A%E7%9F%A5/" rel="alternate" type="text/html" title="Hyprlan微信通知"/><published>2025-09-22T00:00:00+00:00</published><updated>2025-09-22T00:00:00+00:00</updated><id>https://vonwind.github.io/blog/2025/Hyprlan%E5%BE%AE%E4%BF%A1%E9%80%9A%E7%9F%A5</id><content type="html" xml:base="https://vonwind.github.io/blog/2025/Hyprlan%E5%BE%AE%E4%BF%A1%E9%80%9A%E7%9F%A5/"><![CDATA[<p>from Grok</p> <p>hyprland 使用一个软件比如telegram通知怎么配置</p> <h3 id="在-hyprland-中配置微信等软件的通知">在 Hyprland 中配置微信等软件的通知</h3> <p>Hyprland 作为 Wayland 合成器，需要外部通知守护进程来处理应用通知。微信（通常指 WeChat for Linux 或 uos-wechat 等第三方客户端）通过 D-Bus 发送通知，与 Telegram 类似。推荐使用 <strong>mako</strong>（轻量 Wayland 原生支持）或 <strong>dunst</strong>。以下是完整配置步骤，基于 Arch Linux（其他发行版调整包管理器即可）。</p> <h4 id="步骤-1-安装微信和通知守护进程">步骤 1: 安装微信和通知守护进程</h4> <ul> <li><strong>安装微信</strong>： <ul> <li>官方 WeChat for Linux（如果可用）：从 <a href="https://weixin.qq.com/">腾讯官网</a> 下载 .deb/.rpm，或使用 AUR： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yay -S wechat-for-linux  # Arch/AUR 用户
# 或 flatpak install flathub com.qq.weixin.work
</code></pre></div> </div> </li> <li>第三方客户端（如 wechat-uos，推荐稳定）： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yay -S wechat-uos  # 或从 GitHub 下载
</code></pre></div> </div> </li> <li>安装后，在微信设置中启用通知：<strong>我 &gt; 设置 &gt; 通用 &gt; 消息通知 &gt; 开启新消息提醒</strong>。禁用“消息提醒时置顶窗口”以避免焦点切换。</li> </ul> </li> <li><strong>安装通知守护进程</strong>： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo pacman -S mako  # 推荐 mako
# 或 sudo pacman -S dunst  # 备选 dunst
</code></pre></div> </div> </li> </ul> <h4 id="步骤-2-在-hyprland-配置中启动守护进程">步骤 2: 在 Hyprland 配置中启动守护进程</h4> <p>编辑 <code class="language-plaintext highlighter-rouge">~/.config/hypr/hyprland.conf</code>，在 <code class="language-plaintext highlighter-rouge">exec-once</code> 部分添加：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exec-once = mako  # 使用 mako
# 或 exec-once = dunst  # 使用 dunst
</code></pre></div></div> <p>重载配置：<code class="language-plaintext highlighter-rouge">Super + Shift + R</code> 或 <code class="language-plaintext highlighter-rouge">hyprctl reload</code>。</p> <h4 id="步骤-3-配置通知守护进程">步骤 3: 配置通知守护进程</h4> <p>微信通知通常显示为“新消息”标题 + 聊天内容。自定义位置、样式等。</p> <ul> <li><strong>mako 配置</strong>（简单推荐）： 创建/编辑 <code class="language-plaintext highlighter-rouge">~/.config/mako/config</code>： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 全局设置
font=sans-serif 10
background-color=#333333CC  # 半透明背景
text-color=#FFFFFF
border-color=#FFFFFF
border-size=2
border-radius=10
padding=10
margin=10
default-timeout=5000ms  # 5 秒显示

# 位置：右上角
anchor=top-right
layer=overlay

# 紧急通知（微信重要消息）
[urgency=high]
default-timeout=0  # 永久显示
</code></pre></div> </div> <ul> <li><strong>微信特定规则</strong>（可选，匹配 app_name）： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[app-name=WeChat]
default-timeout=8000ms  # 微信通知显示 8 秒
</code></pre></div> </div> </li> </ul> <p>测试：<code class="language-plaintext highlighter-rouge">notify-send -a WeChat "测试" "Hello from WeChat!"</code>。看到通知即成功。</p> </li> <li><strong>dunst 配置</strong>（如果选择 dunst）： 创建/编辑 <code class="language-plaintext highlighter-rouge">~/.config/dunst/dunstrc</code>： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 全局设置
font = sans-serif 10
frame_color = "#FFFFFF"
frame_width = 2
padding = 10
horizontal_padding = 10
text_icon_padding = 10
gap_size = 10

# 位置：右上角
alignment = center
origin = top-right
offset = 10x10

# 颜色和透明度
transparency = 10
background = "#333333CC"
foreground = "#FFFFFF"
markup = full

# 持续时间
timeout = 5

# 微信规则（匹配 app_name="WeChat" 或 "wechat-uos"）
[wechat]
app_name = WeChat
summary = "*"
body = "*"
icon = /usr/share/icons/hicolor/256x256/apps/wechat.png  # 微信图标路径（调整为实际）
timeout = 8  # 8 秒
urgency = normal
</code></pre></div> </div> <p>测试：<code class="language-plaintext highlighter-rouge">notify-send -a WeChat "测试" "新消息!"</code>。重启：<code class="language-plaintext highlighter-rouge">pkill dunst</code>。</p> </li> </ul> <h4 id="步骤-4-处理常见问题">步骤 4: 处理常见问题</h4> <ul> <li><strong>通知不显示</strong>： <ul> <li>测试 D-Bus：<code class="language-plaintext highlighter-rouge">notify-send "Test"</code>。</li> <li>确保微信在 Wayland 模式运行：添加环境变量到 <code class="language-plaintext highlighter-rouge">~/.profile</code>： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export QT_QPA_PLATFORM=wayland
export ELECTRON_OZONE_PLATFORM_HINT=auto  # 如果是 Electron 版微信
</code></pre></div> </div> </li> <li>检查 app_name：运行微信时，用 <code class="language-plaintext highlighter-rouge">notify-send</code> 测试不同名称（如 “WeChat” 或 “org.wechat”），或用 <code class="language-plaintext highlighter-rouge">dbus-monitor</code> 监控（<code class="language-plaintext highlighter-rouge">dbus-monitor --session</code> 发送通知观察）。</li> <li>Flatpak 版微信：添加 <code class="language-plaintext highlighter-rouge">--socket=wayland</code> 启动：<code class="language-plaintext highlighter-rouge">flatpak run --socket=wayland com.qq.weixin.work</code>。</li> </ul> </li> <li><strong>焦点切换或工作区跳转</strong>（微信常见）： <ul> <li>Hyprland 配置添加：<code class="language-plaintext highlighter-rouge">misc { focus_on_activate = false }</code>。</li> <li>窗口规则忽略微信：<code class="language-plaintext highlighter-rouge">windowrulev2 = nofocus,class:^(WeChat)$</code> 或 <code class="language-plaintext highlighter-rouge">windowrulev2 = workspace 10,class:^(WeChat)$</code>（固定到工作区）。</li> <li>微信设置中禁用“新消息弹窗”或“声音提醒”如果干扰。</li> </ul> </li> <li><strong>自定义声音</strong>： <ul> <li>mako/dunst 配置中添加 <code class="language-plaintext highlighter-rouge">sound-file=/usr/share/sounds/freedesktop/stereo/message.ogg</code>（全局）。</li> <li>微信自带声音，确保 PipeWire 运行：<code class="language-plaintext highlighter-rouge">systemctl --user start pipewire pipewire-pulse</code>。</li> </ul> </li> <li><strong>通知历史</strong>（可选）： <ul> <li>安装 <code class="language-plaintext highlighter-rouge">swaync</code>：<code class="language-plaintext highlighter-rouge">sudo pacman -S swaync</code>，Hyprland conf 添加 <code class="language-plaintext highlighter-rouge">exec-once = swaync -g floating</code>。提供 GUI 查看/过滤微信通知。</li> </ul> </li> </ul> <h4 id="测试微信通知">测试微信通知</h4> <ol> <li>重启 Hyprland。</li> <li>打开微信，让朋友发消息或自发测试消息。</li> <li>右上角应弹出通知，点击可跳转聊天。</li> </ol> <p>如果微信是特定版本（如 wechat-for-linux），app_name 可能为 “WeCom” 或 “WeChatWork”，调整规则相应。问题排查：查看 <code class="language-plaintext highlighter-rouge">hyprctl logs</code> 或 <a href="https://wiki.hyprland.org/Useful-Utilities/Notification-Daemons/">Hyprland Wiki</a>。更多微信 Linux 细节见 <a href="https://wiki.archlinux.org/title/WeChat">Arch Wiki</a>。配置类似其他 IM 应用！</p> <p>👌 那我帮你写一个 <strong>自动检测工具</strong>，可以快速找出某个应用窗口的 <code class="language-plaintext highlighter-rouge">class</code> 和启动命令，方便配置到脚本里。</p> <hr/> <h2 id="脚本scriptsfind-app-classsh">脚本：<code class="language-plaintext highlighter-rouge">~/scripts/find-app-class.sh</code></h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>
<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="nv">APP</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">1</span><span class="k">:-}</span><span class="s2">"</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"用法: </span><span class="nv">$0</span><span class="s2"> &lt;关键字&gt;"</span>
  <span class="nb">echo</span> <span class="s2">"例如: </span><span class="nv">$0</span><span class="s2"> wechat"</span>
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">"正在查找包含 '</span><span class="nv">$APP</span><span class="s2">' 的窗口..."</span>

hyprctl clients <span class="nt">-j</span> | jq <span class="nt">-r</span> <span class="nt">--arg</span> app <span class="s2">"</span><span class="nv">$APP</span><span class="s2">"</span> <span class="s1">'
  .[]
  | select(
      (.class // "" | ascii_downcase | contains($app|ascii_downcase))
      or
      (.title // "" | ascii_downcase | contains($app|ascii_downcase))
    )
  | "class=\(.class)  title=\(.title)  address=\(.address)  ws=\(.workspace.id)"'</span>
</code></pre></div></div> <hr/> <h2 id="用法">用法</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x ~/scripts/find-app-class.sh
~/scripts/find-app-class.sh wechat
</code></pre></div></div> <p>输出示例（不同应用会不一样）：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class=WeChat.exe  title=微信  address=0x55a6f3b  ws=2
</code></pre></div></div> <p>这样你就知道：</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">class</code> 是 <code class="language-plaintext highlighter-rouge">WeChat.exe</code>，那么在 <code class="language-plaintext highlighter-rouge">toggle-app.sh</code> 里传参要写 <code class="language-plaintext highlighter-rouge">WeChat.exe</code>（大小写敏感！）。</p> </li> <li> <p>启动命令则是你平时运行微信的命令，比如 <code class="language-plaintext highlighter-rouge">/opt/deepinwine/apps/Deepin-WeChat/wechat</code>。</p> </li> </ul> <hr/> <h2 id="配置-hyprland-绑定">配置 Hyprland 绑定</h2> <p>拿到结果后，比如你发现微信的 class 是 <code class="language-plaintext highlighter-rouge">WeChat.exe</code>，就写：</p> <div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">bind</span> <span class="p">=</span> <span class="s">SUPER, W, exec, ~/scripts/toggle-app.sh WeChat.exe "/opt/deepinwine/apps/Deepin-WeChat/wechat"</span>
</code></pre></div></div> <p>这样脚本才能正确匹配窗口。</p> <hr/> <p>要不要我顺便帮你做一个 <strong>一键生成 Hyprland 配置行</strong> 的小脚本？比如你输入 <code class="language-plaintext highlighter-rouge">wechat /opt/deepinwine/apps/Deepin-WeChat/wechat</code>，它就自动输出正确的 <code class="language-plaintext highlighter-rouge">bind = ...</code> 配置。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Zero测试</title><link href="https://vonwind.github.io/blog/2025/zero%E6%B5%8B%E8%AF%95/" rel="alternate" type="text/html" title="Zero测试"/><published>2025-09-17T00:00:00+00:00</published><updated>2025-09-17T00:00:00+00:00</updated><id>https://vonwind.github.io/blog/2025/zero%E6%B5%8B%E8%AF%95</id><content type="html" xml:base="https://vonwind.github.io/blog/2025/zero%E6%B5%8B%E8%AF%95/"><![CDATA[<p>放是科技的离开房间</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌──(raven😈😈💀💀💀😈😈kali)-[~]
└─$ ls -l  
total 132
drwxrwxr-x  3 raven raven  4096 Aug  6 13:40 1
-rw-r--r--  1 raven raven 40960 May 27 17:14 111.ctb
-rw-rw-r--  1 raven raven   918 Sep 17 16:08 _custom.scss
drwxr-xr-x  2 raven raven  4096 Sep 16 16:31 Desktop
drwxr-xr-x  3 raven raven  4096 May 20 09:37 Documents
drwxr-xr-x  6 raven raven  4096 Sep 16 10:54 Downloads

</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[放是科技的离开房间]]></summary></entry><entry><title type="html">a post with plotly.js</title><link href="https://vonwind.github.io/blog/2025/plotly/" rel="alternate" type="text/html" title="a post with plotly.js"/><published>2025-03-26T14:24:00+00:00</published><updated>2025-03-26T14:24:00+00:00</updated><id>https://vonwind.github.io/blog/2025/plotly</id><content type="html" xml:base="https://vonwind.github.io/blog/2025/plotly/"><![CDATA[<p>This is an example post with some <a href="https://plotly.com/javascript/">plotly</a> code.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">plotly
</span><span class="sb">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "type": "scatter"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [16, 5, 11, 9],
      "type": "scatter"
    }
  ]
}</span>
<span class="p">```</span>
</code></pre></div></div> <p>Which generates:</p> <pre><code class="language-plotly">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "type": "scatter"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [16, 5, 11, 9],
      "type": "scatter"
    }
  ]
}
</code></pre> <p>Also another example chart.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">plotly
</span><span class="sb">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "mode": "markers"
    },
    {
      "x": [2, 3, 4, 5],
      "y": [16, 5, 11, 9],
      "mode": "lines"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [12, 9, 15, 12],
      "mode": "lines+markers"
    }
  ],
  "layout": {
    "title": {
      "text": "Line and Scatter Plot"
    }
  }
}</span>
<span class="p">```</span>
</code></pre></div></div> <p>This is how it looks like:</p> <pre><code class="language-plotly">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "mode": "markers"
    },
    {
      "x": [2, 3, 4, 5],
      "y": [16, 5, 11, 9],
      "mode": "lines"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [12, 9, 15, 12],
      "mode": "lines+markers"
    }
  ],
  "layout": {
    "title": {
      "text": "Line and Scatter Plot"
    }
  }
}
</code></pre>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="charts"/><summary type="html"><![CDATA[this is what included plotly.js code could look like]]></summary></entry><entry><title type="html">a post with image galleries</title><link href="https://vonwind.github.io/blog/2024/photo-gallery/" rel="alternate" type="text/html" title="a post with image galleries"/><published>2024-12-04T01:59:00+00:00</published><updated>2024-12-04T01:59:00+00:00</updated><id>https://vonwind.github.io/blog/2024/photo-gallery</id><content type="html" xml:base="https://vonwind.github.io/blog/2024/photo-gallery/"><![CDATA[<p>The images in this post are all zoomable, arranged into different mini-galleries using different libraries.</p> <h2 id="lightbox2"><a href="https://lokeshdhakar.com/projects/lightbox2/">Lightbox2</a></h2> <p><a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-2500.jpg" data-lightbox="roadtrip"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-200.jpg"/></a> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg" data-lightbox="roadtrip"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg"/></a> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg" data-lightbox="roadtrip"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg"/></a></p> <hr/> <h2 id="photoswipe"><a href="https://photoswipe.com/">PhotoSwipe</a></h2> <div class="pswp-gallery pswp-gallery--single-column" id="gallery--getting-started"> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg" data-pswp-width="1669" data-pswp-height="2500" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg" alt=""/> </a> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/7/img-2500.jpg" data-pswp-width="1875" data-pswp-height="2500" data-cropped="true" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/7/img-200.jpg" alt=""/> </a> <a href="https://unsplash.com" data-pswp-src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg" data-pswp-width="2500" data-pswp-height="1666" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg" alt=""/> </a> <div> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-2500.jpg" data-pswp-width="2500" data-pswp-height="1667" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-200.jpg" alt=""/> </a> </div> </div> <hr/> <h2 id="spotlight-js"><a href="https://nextapps-de.github.io/spotlight/">Spotlight JS</a></h2> <div class="spotlight-group"> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg"/> </a> </div> <div class="spotlight-group"> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/4/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/4/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/5/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/5/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-200.jpg"/> </a> </div> <hr/> <h2 id="venobox"><a href="https://veno.es/venobox/">Venobox</a></h2> <p><a class="venobox" data-gall="myGallery" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-2500.jpg"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-200.jpg"/></a> <a class="venobox" data-gall="myGallery" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg"/></a> <a class="venobox" data-gall="myGallery" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg"/></a></p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="images"/><summary type="html"><![CDATA[this is what included image galleries could look like]]></summary></entry><entry><title type="html">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</title><link href="https://vonwind.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/" rel="alternate" type="text/html" title="Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra"/><published>2024-05-14T00:00:00+00:00</published><updated>2024-05-14T00:00:00+00:00</updated><id>https://vonwind.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra</id><content type="html" xml:base="https://vonwind.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/"><![CDATA[<p>May 14, 2024 We’re introducing a series of updates across the Gemini family of models, including the new 1.5 Flash, our lightweight model for speed and efficiency, and Project Astra, our vision for the future of AI assistants. In December, we launched our first natively multimodal model Gemini 1.0 in three sizes: Ultra, Pro and Nano. Just a few months later we released 1.5 Pro, with enhanced performance and a breakthrough long context window of 1 million tokens.Developers and enterprise customers have been putting 1.5 Pro to use in incredible ways and finding its long context window, multimodal reasoning capabilities and impressive overall performance incredibly useful.We know from user feedback that some applications need lower latency and a lower cost to serve. This inspired us to keep innovating, so today, we’re introducing Gemini 1.5 Flash: a model that’s lighter-weight than 1.5 Pro, and designed to be fast and efficient to serve at scale.Both 1.5 Pro and 1.5 Flash are available in public preview with a 1 million token context window in Google AI Studio and Vertex AI. And now, 1.5 Pro is also available with a 2 million token context window via waitlist to developers using the API and to Google Cloud customers.We’re also introducing updates across the Gemini family of models, announcing our next generation of open models, Gemma 2, and sharing progress on the future of AI assistants, with Project Astra.Context lengths of leading foundation models compared with Gemini 1.5’s 2 million token capability1.5 Flash is the newest addition to the Gemini model family and the fastest Gemini model served in the API. It’s optimized for high-volume, high-frequency tasks at scale, is more cost-efficient to serve and features our breakthrough long context window.While it’s a lighter weight model than 1.5 Pro, it’s highly capable of multimodal reasoning across vast amounts of information and delivers impressive quality for its size.The new Gemini 1.5 Flash model is optimized for speed and efficiency, is highly capable of multimodal reasoning and features our breakthrough long context window.1.5 Flash excels at summarization, chat applications, image and video captioning, data extraction from long documents and tables, and more. This is because it’s been trained by 1.5 Pro through a process called “distillation,” where the most essential knowledge and skills from a larger model are transferred to a smaller, more efficient model.Read more about 1.5 Flash in our updated Gemini 1.5 technical report, on the Gemini technology page, and learn about 1.5 Flash’s availability and pricing.Over the last few months, we’ve significantly improved 1.5 Pro, our best model for general performance across a wide range of tasks.Beyond extending its context window to 2 million tokens, we’ve enhanced its code generation, logical reasoning and planning, multi-turn conversation, and audio and image understanding through data and algorithmic advances. We see strong improvements on public and internal benchmarks for each of these tasks.1.5 Pro can now follow increasingly complex and nuanced instructions, including ones that specify product-level behavior involving role, format and style. We’ve improved control over the model’s responses for specific use cases, like crafting the persona and response style of a chat agent or automating workflows through multiple function calls. And we’ve enabled users to steer model behavior by setting system instructions.We added audio understanding in the Gemini API and Google AI Studio, so 1.5 Pro can now reason across image and audio for videos uploaded in Google AI Studio. And we’re now integrating 1.5 Pro into Google products, including Gemini Advanced and in Workspace apps.Read more about 1.5 Pro in our updated Gemini 1.5 technical report and on the Gemini technology page.Gemini Nano is expanding beyond text-only inputs to include images as well. Starting with Pixel, applications using Gemini Nano with Multimodality will be able to understand the world the way people do — not just through text, but also through sight, sound and spoken language.Read more about Gemini 1.0 Nano on Android.Today, we’re also sharing a series of updates to Gemma, our family of open models built from the same research and technology used to create the Gemini models.We’re announcing Gemma 2, our next generation of open models for responsible AI innovation. Gemma 2 has a new architecture designed for breakthrough performance and efficiency, and will be available in new sizes.The Gemma family is also expanding with PaliGemma, our first vision-language model inspired by PaLI-3. And we’ve upgraded our Responsible Generative AI Toolkit with LLM Comparator for evaluating the quality of model responses.Read more on the Developer blog.As part of Google DeepMind’s mission to build AI responsibly to benefit humanity, we’ve always wanted to develop universal AI agents that can be helpful in everyday life. That’s why today, we’re sharing our progress in building the future of AI assistants with Project Astra (advanced seeing and talking responsive agent).To be truly useful, an agent needs to understand and respond to the complex and dynamic world just like people do — and take in and remember what it sees and hears to understand context and take action. It also needs to be proactive, teachable and personal, so users can talk to it naturally and without lag or delay.While we’ve made incredible progress developing AI systems that can understand multimodal information, getting response time down to something conversational is a difficult engineering challenge. Over the past few years, we’ve been working to improve how our models perceive, reason and converse to make the pace and quality of interaction feel more natural.Building on Gemini, we’ve developed prototype agents that can process information faster by continuously encoding video frames, combining the video and speech input into a timeline of events, and caching this information for efficient recall.By leveraging our leading speech models, we also enhanced how they sound, giving the agents a wider range of intonations. These agents can better understand the context they’re being used in, and respond quickly, in conversation.With technology like this, it’s easy to envision a future where people could have an expert AI assistant by their side, through a phone or glasses. And some of these capabilities are coming to Google products, like the Gemini app and web experience, later this year.We’ve made incredible progress so far with our family of Gemini models, and we’re always striving to advance the state-of-the-art even further. By investing in a relentless production line of innovation, we’re able to explore new ideas at the frontier, while also unlocking the possibility of new and exciting Gemini use cases.Learn more about Gemini and its capabilities. Your information will be used in accordance with Google’s privacy policy.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      Done. Just one step more.
    
      Check your inbox to confirm your subscription.
    You are already subscribed to our newsletter.
    You can also subscribe with a
    different email address
    
    .
    
  Let’s stay in touch. Get the latest news from Google in your inbox.
          Follow Us
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[We’re sharing updates across our Gemini family of models and a glimpse of Project Astra, our vision for the future of AI assistants.]]></summary></entry><entry><title type="html">a post with tabs</title><link href="https://vonwind.github.io/blog/2024/tabs/" rel="alternate" type="text/html" title="a post with tabs"/><published>2024-05-01T00:32:13+00:00</published><updated>2024-05-01T00:32:13+00:00</updated><id>https://vonwind.github.io/blog/2024/tabs</id><content type="html" xml:base="https://vonwind.github.io/blog/2024/tabs/"><![CDATA[<p>This is how a post with <a href="https://github.com/Ovski4/jekyll-tabs">tabs</a> looks like. Note that the tabs could be used for different purposes, not only for code.</p> <h2 id="first-tabs">First tabs</h2> <p>To add tabs, use the following syntax:</p> <div class="language-liquid highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{%</span><span class="w"> </span><span class="nt">tabs</span><span class="w"> </span><span class="nv">group-name</span><span class="w"> </span><span class="cp">%}</span>

<span class="cp">{%</span><span class="w"> </span><span class="nt">tab</span><span class="w"> </span><span class="nv">group-name</span><span class="w"> </span><span class="nv">tab-name-1</span><span class="w"> </span><span class="cp">%}</span>

Content 1

<span class="cp">{%</span><span class="w"> </span><span class="nt">endtab</span><span class="w"> </span><span class="cp">%}</span>

<span class="cp">{%</span><span class="w"> </span><span class="nt">tab</span><span class="w"> </span><span class="nv">group-name</span><span class="w"> </span><span class="nv">tab-name-2</span><span class="w"> </span><span class="cp">%}</span>

Content 2

<span class="cp">{%</span><span class="w"> </span><span class="nt">endtab</span><span class="w"> </span><span class="cp">%}</span>

<span class="cp">{%</span><span class="w"> </span><span class="nt">endtabs</span><span class="w"> </span><span class="cp">%}</span>
</code></pre></div></div> <p>With this you can generate visualizations like:</p> <ul id="log" class="tab" data-tab="3aa00e40-b52e-434f-a351-ef6dabebad02" data-name="log"> <li class="active" id="log-php"> <a href="#">php </a> </li> <li id="log-js"> <a href="#">js </a> </li> <li id="log-ruby"> <a href="#">ruby </a> </li> </ul> <ul class="tab-content" id="3aa00e40-b52e-434f-a351-ef6dabebad02" data-name="log"> <li class="active"> <div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">var_dump</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">);</span>
</code></pre></div></div> </li> <li> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div> </li> <li> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">pputs</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
</code></pre></div></div> </li> </ul> <h2 id="another-example">Another example</h2> <ul id="data-struct" class="tab" data-tab="bf26fdf9-b0fe-4d65-834e-93c25ec60cf6" data-name="data-struct"> <li class="active" id="data-struct-yaml"> <a href="#">yaml </a> </li> <li id="data-struct-json"> <a href="#">json </a> </li> </ul> <ul class="tab-content" id="bf26fdf9-b0fe-4d65-834e-93c25ec60cf6" data-name="data-struct"> <li class="active"> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">hello</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">whatsup"</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">hi"</span>
</code></pre></div></div> </li> <li> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"hello"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"whatsup"</span><span class="p">,</span><span class="w"> </span><span class="s2">"hi"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> </li> </ul> <h2 id="tabs-for-something-else">Tabs for something else</h2> <ul id="something-else" class="tab" data-tab="5bd0419d-1e48-49a1-9c3f-51896f0d5dd3" data-name="something-else"> <li class="active" id="something-else-text"> <a href="#">text </a> </li> <li id="something-else-quote"> <a href="#">quote </a> </li> <li id="something-else-list"> <a href="#">list </a> </li> </ul> <ul class="tab-content" id="5bd0419d-1e48-49a1-9c3f-51896f0d5dd3" data-name="something-else"> <li class="active"> <p>Regular text</p> </li> <li> <blockquote> <p>A quote</p> </blockquote> </li> <li> <p>Hipster list</p> <ul> <li>brunch</li> <li>fixie</li> <li>raybans</li> <li>messenger bag</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="code"/><summary type="html"><![CDATA[this is what included tabs in a post could look like]]></summary></entry><entry><title type="html">a post with typograms</title><link href="https://vonwind.github.io/blog/2024/typograms/" rel="alternate" type="text/html" title="a post with typograms"/><published>2024-04-29T23:36:10+00:00</published><updated>2024-04-29T23:36:10+00:00</updated><id>https://vonwind.github.io/blog/2024/typograms</id><content type="html" xml:base="https://vonwind.github.io/blog/2024/typograms/"><![CDATA[<p>This is an example post with some <a href="https://github.com/google/typograms/">typograms</a> code.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">typograms
</span><span class="sb">+----+
|    |---&gt; My first diagram!
+----+</span>
<span class="p">```</span>
</code></pre></div></div> <p>Which generates:</p> <pre><code class="language-typograms">+----+
|    |---&gt; My first diagram!
+----+
</code></pre> <p>Another example:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">typograms
</span><span class="sb">.------------------------.
|.----------------------.|
||"https://example.com" ||
|'----------------------'|
| ______________________ |
||                      ||
||   Welcome!           ||
||                      ||
||                      ||
||  .----------------.  ||
||  | username       |  ||
||  '----------------'  ||
||  .----------------.  ||
||  |"*******"       |  ||
||  '----------------'  ||
||                      ||
||  .----------------.  ||
||  |   "Sign-up"    |  ||
||  '----------------'  ||
||                      ||
|+----------------------+|
.------------------------.</span>
<span class="p">```</span>
</code></pre></div></div> <p>which generates:</p> <pre><code class="language-typograms">.------------------------.
|.----------------------.|
||"https://example.com" ||
|'----------------------'|
| ______________________ |
||                      ||
||   Welcome!           ||
||                      ||
||                      ||
||  .----------------.  ||
||  | username       |  ||
||  '----------------'  ||
||  .----------------.  ||
||  |"*******"       |  ||
||  '----------------'  ||
||                      ||
||  .----------------.  ||
||  |   "Sign-up"    |  ||
||  '----------------'  ||
||                      ||
|+----------------------+|
.------------------------.
</code></pre> <p>For more examples, check out the <a href="https://google.github.io/typograms/#examples">typograms documentation</a>.</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="diagrams"/><summary type="html"><![CDATA[this is what included typograms code could look like]]></summary></entry><entry><title type="html">a post that can be cited</title><link href="https://vonwind.github.io/blog/2024/post-citation/" rel="alternate" type="text/html" title="a post that can be cited"/><published>2024-04-28T15:06:00+00:00</published><updated>2024-04-28T15:06:00+00:00</updated><id>https://vonwind.github.io/blog/2024/post-citation</id><content type="html" xml:base="https://vonwind.github.io/blog/2024/post-citation/"><![CDATA[<p>This is an example post that can be cited. The content of the post ends here, while the citation information is automatically provided below. The only thing needed is for you to set the <code class="language-plaintext highlighter-rouge">citation</code> key in the front matter to <code class="language-plaintext highlighter-rouge">true</code>.</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="citation"/><summary type="html"><![CDATA[this is what a post that can be cited looks like]]></summary></entry><entry><title type="html">a post with pseudo code</title><link href="https://vonwind.github.io/blog/2024/pseudocode/" rel="alternate" type="text/html" title="a post with pseudo code"/><published>2024-04-15T00:01:00+00:00</published><updated>2024-04-15T00:01:00+00:00</updated><id>https://vonwind.github.io/blog/2024/pseudocode</id><content type="html" xml:base="https://vonwind.github.io/blog/2024/pseudocode/"><![CDATA[<p>This is an example post with some pseudo code rendered by <a href="https://github.com/SaswatPadhi/pseudocode.js">pseudocode</a>. The example presented here is the same as the one in the <a href="https://saswat.padhi.me/pseudocode.js/">pseudocode.js</a> documentation, with only one simple but important change: everytime you would use <code class="language-plaintext highlighter-rouge">$</code>, you should use <code class="language-plaintext highlighter-rouge">$$</code> instead. Also, note that the <code class="language-plaintext highlighter-rouge">pseudocode</code> key in the front matter is set to <code class="language-plaintext highlighter-rouge">true</code> to enable the rendering of pseudo code. As an example, using this code:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">pseudocode
</span><span class="sb">% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)
\begin{algorithm}
\caption{Quicksort}
\begin{algorithmic}
\PROCEDURE{Quicksort}{$$A, p, r$$}
    \IF{$$p &lt; r$$}
        \STATE $$q = $$ \CALL{Partition}{$$A, p, r$$}
        \STATE \CALL{Quicksort}{$$A, p, q - 1$$}
        \STATE \CALL{Quicksort}{$$A, q + 1, r$$}
    \ENDIF
\ENDPROCEDURE
\PROCEDURE{Partition}{$$A, p, r$$}
    \STATE $$x = A[r]$$
    \STATE $$i = p - 1$$
    \FOR{$$j = p$$ \TO $$r - 1$$}
        \IF{$$A[j] &lt; x$$}
            \STATE $$i = i + 1$$
            \STATE exchange
            $$A[i]$$ with $$A[j]$$
        \ENDIF
        \STATE exchange $$A[i]$$ with $$A[r]$$
    \ENDFOR
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}</span>
<span class="p">```</span>
</code></pre></div></div> <p>Generates:</p> <pre><code class="language-pseudocode">% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)
\begin{algorithm}
\caption{Quicksort}
\begin{algorithmic}
\PROCEDURE{Quicksort}{$$A, p, r$$}
    \IF{$$p &lt; r$$}
        \STATE $$q = $$ \CALL{Partition}{$$A, p, r$$}
        \STATE \CALL{Quicksort}{$$A, p, q - 1$$}
        \STATE \CALL{Quicksort}{$$A, q + 1, r$$}
    \ENDIF
\ENDPROCEDURE
\PROCEDURE{Partition}{$$A, p, r$$}
    \STATE $$x = A[r]$$
    \STATE $$i = p - 1$$
    \FOR{$$j = p$$ \TO $$r - 1$$}
        \IF{$$A[j] &lt; x$$}
            \STATE $$i = i + 1$$
            \STATE exchange
            $$A[i]$$ with $$A[j]$$
        \ENDIF
        \STATE exchange $$A[i]$$ with $$A[r]$$
    \ENDFOR
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</code></pre>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="code"/><summary type="html"><![CDATA[this is what included pseudo code could look like]]></summary></entry></feed>