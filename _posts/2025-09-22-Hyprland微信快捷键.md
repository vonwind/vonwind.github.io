---
layout: post
tags:
  - omarchy
  - formatting
---








### 自动检测版脚本

保存为 `~/scripts/wechat-toggle.sh`：
```shell
#!/bin/bash

# 自动检测微信窗口 class
get_wechat_class() {
    hyprctl clients | grep -i "wechat" | grep "class:" | head -n1 | awk '{print $2}'
}

WIN_CLASS=$(get_wechat_class)

# 如果没有检测到，默认用 wechat
if [ -z "$WIN_CLASS" ]; then
    WIN_CLASS="wechat"
fi

# 检查微信是否运行
if ! pgrep -i wechat >/dev/null; then
    # 没有运行就启动
    wechat &
    exit 0
fi

# 微信在运行，检查窗口信息
WIN_INFO=$(hyprctl clients | grep -i "class: $WIN_CLASS" -A 10)

if [ -z "$WIN_INFO" ]; then
    # 没找到窗口（可能在后台），重新启动
    wechat &
    exit 0
fi

# 如果窗口已聚焦 → 最小化到一个隐藏 workspace
if echo "$WIN_INFO" | grep -q "focused: yes"; then
    hyprctl dispatch movetoworkspacesilent special:hidden "class:^(?i)$WIN_CLASS$"
else
    # 否则聚焦到它
    hyprctl dispatch focuswindow "class:^(?i)$WIN_CLASS$"
fi
```


### 使用方法

1. 给权限：
```shell
chmod +x ~/scripts/wechat-toggle.sh
```

2. 在 `~/.config/hypr/hyprland.conf` 里添加：
```shell
bind = SUPER, W, exec, ~/scripts/wechat-toggle.sh
```


这样效果就是：

- `SUPER + W`
    
    - 如果微信没开 → 启动微信
        
    - 如果微信在后台 → 切换到前台
        
    - 如果微信已在前台 → 隐藏到一个 `special:hidden` 的 workspace




## 🔹 改进后的 toggle 脚本（支持跨 workspace）

保存为 `~/scripts/toggle-app.sh`：


```shell
#!/bin/bash
APP=$1

# 检查程序是否运行
if ! pgrep -x "$APP" >/dev/null; then
    $APP &
    exit 0
fi

# 查找窗口信息
WIN_INFO=$(hyprctl clients | awk -v app="$APP" '
    BEGIN {IGNORECASE=1}
    /class:/ {cls=$2}
    /workspace:/ {ws=$2}
    /address:/ {addr=$2}
    /focused:/ {f=$2}
    {
      if (tolower(cls)==tolower(app)) {
        print cls, ws, addr, f
      }
    }')

if [ -z "$WIN_INFO" ]; then
    $APP &
    exit 0
fi

# 解析结果（取第一个匹配窗口）
read CLS WS ADDR FOCUSED <<< "$WIN_INFO"

if [ "$FOCUSED" == "yes" ]; then
    # 如果已聚焦 → 隐藏到 special:hidden
    hyprctl dispatch movetoworkspacesilent special:hidden "class:^(?i)$APP$"
else
    if [ "$WS" != "$(hyprctl activeworkspace -j | jq -r .id)" ]; then
        # 如果在其他 workspace → 切过去
        hyprctl dispatch workspace "$WS"
    fi
    # 聚焦窗口
    hyprctl dispatch focuswindow "class:^(?i)$APP$"
fi

```



## 🔹 使用方式

1. 给执行权限：
```shell
chmod +x ~/scripts/toggle-app.sh
```


2. 在 ~/.config/hypr/hyprland.conf 里配置：
```shell
bind = SUPER, W, exec, ~/scripts/toggle-app.sh wechat
bind = SUPER, T, exec, ~/scripts/toggle-app.sh telegram-desktop
bind = SUPER, B, exec, ~/scripts/toggle-app.sh firefox
bind = SUPER, Return, exec, ~/scripts/toggle-app.sh kitty
```


## 🔹 效果

- 如果没运行 → 启动
    
- 如果在当前 workspace → 聚焦或隐藏
    
- 如果在其他 workspace → 自动切换到对应 workspace 并聚焦
    
- 再按一次 → 隐藏到 `special:hidden`


```
$(hyprctl clients | awk -v app="wechat" '
    BEGIN {IGNORECASE=1}
    /class:/ {cls=$2}
    /workspace:/ {ws=$2}
    /address:/ {addr=$2}
    /focused:/ {f=$2}
    {
      if (tolower(cls)==tolower(app)) {
        print cls, ws, addr, f
      }
    }')
    
    
    hyprctl clients -j | jq -r --arg app "wechat" '
    .[] | select(.class | ascii_downcase == ($app | ascii_downcase)) 
    | "\(.class) \(.workspace.id) \(.address)"' | head -n1
    
```




没有focused


啊，明白了 👍。  
你在 `hyprctl clients` 里看到的输出里 **没有 `focused:` 字段**，这是因为 Hyprland 在不同版本里 `clients` 的输出格式变过。

有的版本里 `hyprctl clients` 输出的是：
```shell
class: firefox
title: Mozilla Firefox
workspace: 2
address: 0x55d9e6e
at: 1920,30
...
focusHistoryID: 12

```

没有 `focused: yes/no`。  
要判断某个窗口是不是前台，就要**对比它的 workspace 和当前活动的 workspace**。



## 🔹 改进版（兼容没有 `focused` 字段的情况）

更新后的 `toggle-app.sh`：

```shell
#!/bin/bash
APP=$1

# 检查程序是否运行
if ! pgrep -x "$APP" >/dev/null; then
    $APP &
    exit 0
fi

# 当前 workspace ID
CUR_WS=$(hyprctl activeworkspace -j | jq -r .id)

# 查找第一个匹配的窗口
WIN_INFO=$(hyprctl clients -j | jq -r --arg app "$APP" '
    .[] | select(.class | ascii_downcase == ($app | ascii_downcase)) 
    | "\(.class) \(.workspace.id) \(.address)"' | head -n1)

if [ -z "$WIN_INFO" ]; then
    $APP &
    exit 0
fi

read CLS WS ADDR <<< "$WIN_INFO"

if [ "$WS" -eq "$CUR_WS" ]; then
    # 如果在当前 workspace → 隐藏到 special:hidden
    hyprctl dispatch movetoworkspacesilent special:hidden "address:$ADDR"
else
    # 如果在其他 workspace → 切换并聚焦
    hyprctl dispatch workspace "$WS"
    hyprctl dispatch focuswindow "address:$ADDR"
fi

```


## 🔹 关键点

- 这里用 `hyprctl clients -j`（JSON 格式），再用 `jq` 解析：
    
    - `.class` → 应用类名
        
    - `.workspace.id` → 窗口所在的 workspace
        
    - `.address` → 窗口地址（唯一 ID）
        
- 判断逻辑改成：
    
    - **在当前 workspace** → 隐藏到 `special:hidden`
        
    - **在其他 workspace** → 切换过去并聚焦



## 🔹 配置方式

同样在 `hyprland.conf` 里写：

```shell
bind = SUPER, W, exec, ~/scripts/toggle-app.sh wechat
bind = SUPER, T, exec, ~/scripts/toggle-app.sh telegram-desktop
bind = SUPER, B, exec, ~/scripts/toggle-app.sh firefox

```


这样就不会依赖 `focused` 字段了 ✅。


******************************************

隐藏后再打开 不平铺窗口


👌 你说的情况是：  
脚本里把窗口 **移到 `special:hidden`** workspace 之后，再切回来时，窗口不是平铺状态了（比如变成浮动、尺寸乱掉）。

这是因为：

- `special:hidden` 本身是一个 **特殊 workspace**，窗口切进去切出来时，Hyprland 可能会改变它的 **tiling/floating 状态**。
    
- 另外，`hyprctl dispatch movetoworkspacesilent` 没有强制保持 tiling。


## 🔹 解决思路

1. **记录窗口原本的状态**（tiling/floating）。
    
2. 隐藏时 → 移到 `special:hidden`。
    
3. 再显示时 → 把它移回原来的 workspace，并恢复 tiling 状态。

## 🔹 改进脚本：保证窗口恢复平铺

保存为 `~/scripts/toggle-app.sh`：

```shell
#!/bin/bash
APP=$1

STATE_FILE="/tmp/hypr_toggle_${APP}.state"

# 检查程序是否运行
if ! pgrep -x "$APP" >/dev/null; then
    $APP &
    exit 0
fi

CUR_WS=$(hyprctl activeworkspace -j | jq -r .id)

# 找窗口信息
WIN_INFO=$(hyprctl clients -j | jq -r --arg app "$APP" '
    .[] | select(.class | ascii_downcase == ($app | ascii_downcase))
    | "\(.workspace.id) \(.address) \(.floating)"' | head -n1)

if [ -z "$WIN_INFO" ]; then
    $APP &
    exit 0
fi

read WS ADDR FLOATING <<< "$WIN_INFO"

if [ "$WS" -eq "$CUR_WS" ]; then
    # 已在当前 workspace → 隐藏
    echo "$CUR_WS $FLOATING" > "$STATE_FILE"
    hyprctl dispatch movetoworkspacesilent special:hidden "address:$ADDR"
else
    if [ "$WS" = "special:hidden" ]; then
        # 从隐藏恢复 → 移回原 workspace
        if [ -f "$STATE_FILE" ]; then
            read OLD_WS OLD_FLOATING < "$STATE_FILE"
            hyprctl dispatch movetoworkspacesilent "$OLD_WS" "address:$ADDR"
            # 恢复 tiling 状态
            if [ "$OLD_FLOATING" == "false" ]; then
                hyprctl dispatch toggletiling "address:$ADDR"
            fi
            rm "$STATE_FILE"
        else
            hyprctl dispatch movetoworkspacesilent "$CUR_WS" "address:$ADDR"
        fi
    else
        # 在其他 workspace → 切过去并聚焦
        hyprctl dispatch workspace "$WS"
        hyprctl dispatch focuswindow "address:$ADDR"
    fi
fi

```

## 🔹 逻辑说明

- 第一次隐藏时 → 把 **原 workspace + 是否浮动** 写到 `/tmp/hypr_toggle_APP.state`。
    
- 再次切换时 → 如果窗口在 `special:hidden`，就：
    
    1. 移回原 workspace
        
    2. 如果之前是 tiling → 强制 `toggletiling`，保证不是浮动。

这样你就能做到：

- **按快捷键 → 隐藏**（移到 hidden）
    
- **再按一次 → 恢复到原 workspace，并保持平铺**




++++++++++++++++++++++++++++++++++++++++++++++++++++


这样改都不能隐藏了


Thought for 1m 13s

好——没关系，我们一步步把它修好。你说“这样改都不能隐藏了”，**最常见的原因**有两条，我先把原因说清楚再给你一个实战可用的脚本（含调试日志、回退策略），你直接替换试一下：

原因总结（简短）

- `movetoworkspacesilent` + `special` 的组合在不同 Hyprland 版本/实现上行为不稳定或未完全支持，社区里有相关 report（所以直接用 `movetoworkspacesilent "special,..."` 可能没作用）。[GitHub](https://github.com/hyprwm/Hyprland/issues/1452?utm_source=chatgpt.com)
    
- Special workspace 本身有一些限制（例如 special 的浮动/tiling 行为和普通 workspace 不完全一样），window 在 special 与恢复时状态会被 compositor 改变。文档也指出 special 的行为与普通 workspace 不同。[Hyprland Wiki](https://wiki.hypr.land/0.18.0beta/Configuring/Dispatchers/?utm_source=chatgpt.com)
    

因此我们要做两件事：

1. 把隐藏逻辑做得更**稳健**（先尝试最优 API，失败就降级到可靠的 workaround）；
    
2. 回显（恢复）时**明确用 `address:` 指定窗口**并在必要时做二次恢复（防止被动成浮动）。



# 推荐脚本（带调试 + 回退）

把下面保存为 `~/scripts/wechat-toggle.sh`（或你原来的脚本名），并 `chmod +x`。这个脚本会记录日志 `/tmp/hypr_toggle_debug.log`，并尝试多种方式来隐藏/恢复（先试 silent，失败就用 movetoworkspace+切回 的 fallback）：

```shell
#!/usr/bin/env bash
set -euo pipefail
APP="$1"
STATE_DIR="/tmp/hypr_toggle_states"
LOG="/tmp/hypr_toggle_debug.log"
mkdir -p "$STATE_DIR"
: >"$LOG"

dbg(){ echo "$(date +%T) $*" >>"$LOG"; }

# find first matching window's address
WIN_JSON=$(hyprctl clients -j 2>/dev/null || echo "[]")
ADDR=$(echo "$WIN_JSON" | jq -r --arg app "$APP" '
  .[] | select((.class // "" | ascii_downcase) == ($app|ascii_downcase)) | .address' | head -n1 || true)

if [ -z "$ADDR" ] || [ "$ADDR" = "null" ]; then
  dbg "No running window for '$APP' found. Starting it."
  # 修改为你的启动命令（如果可执行名不同）
  $APP & disown
  exit 0
fi

# workspace ids and names
WIN_WS=$(echo "$WIN_JSON" | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | (.workspace.id // "-1")' )
WIN_WS_NAME=$(echo "$WIN_JSON" | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | (.workspace.name // "")' )
CUR_WS=$(hyprctl activeworkspace -j | jq -r .id)

dbg "Found $APP addr=$ADDR ws=$WIN_WS ws_name='$WIN_WS_NAME' cur_ws=$CUR_WS"

STATE_FILE="$STATE_DIR/${ADDR}.state"

# Helper to re-query where the window is now
where_is() {
  hyprctl clients -j | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | (.workspace.id // "-1")' || echo "-1"
}

# 1) 如果窗口在当前 workspace -> 隐藏（move to special）
if [ "$WIN_WS" -eq "$CUR_WS" ]; then
  dbg "Attempting to hide (current ws)"
  # 保存原 workspace 到状态文件，便于恢复
  echo "$CUR_WS" > "$STATE_FILE"

  # 尝试 1: movetoworkspacesilent special,address:ADDR （优雅但可能不支持 special）
  if hyprctl dispatch movetoworkspacesilent "special,address:${ADDR}" >/dev/null 2>&1; then
    sleep 0.05
    NEWWS=$(where_is)
    if [ "$NEWWS" != "$CUR_WS" ]; then
      dbg "Hidden via movetoworkspacesilent to ws=$NEWWS"
      exit 0
    fi
    dbg "movetoworkspacesilent didn't move the window (no-op)."
  else
    dbg "movetoworkspacesilent returned non-zero or errored."
  fi

  # 回退方案（可靠）：movetoworkspace special (会切到 special)，再切回原 workspace
  dbg "Fallback: movetoworkspace special + switch back to $CUR_WS"
  hyprctl dispatch movetoworkspace "special,address:${ADDR}"
  # 切回之前的 workspace（这样用户感觉没有切换到 special）
  hyprctl dispatch workspace "$CUR_WS"
  sleep 0.05
  NEWWS=$(where_is)
  dbg "After fallback, window ws=$NEWWS"
  exit 0
fi

# 2) 如果窗口不在当前 workspace
# 检查是否在 special（判断 workspace 名或特殊 id）
IS_SPECIAL=false
# 有些 hyprctl 版本会在 .workspace.name / .workspace.special 提供信息；我们尽量容错判断
if [ "$WIN_WS" = "-1" ] || echo "$WIN_WS_NAME" | grep -qi "special"; then
  IS_SPECIAL=true
fi

if $IS_SPECIAL; then
  dbg "Window appears to be in special workspace -> restoring"

  # 读取之前保存的原 workspace（没有就用当前）
  if [ -f "$STATE_FILE" ]; then
    OLD_WS=$(cat "$STATE_FILE")
  else
    OLD_WS="$CUR_WS"
  fi

  dbg "Trying movetoworkspacesilent back to $OLD_WS"
  if hyprctl dispatch movetoworkspacesilent "${OLD_WS},address:${ADDR}" >/dev/null 2>&1; then
    sleep 0.05
    hyprctl dispatch workspace "$OLD_WS"
    hyprctl dispatch focuswindow "address:${ADDR}"
    rm -f "$STATE_FILE"
    dbg "Restored via movetoworkspacesilent to $OLD_WS"
    exit 0
  fi

  dbg "Fallback restore: toggling special/showing + movetoworkspace back"
  # best-effort fallback: show special, then move the window back (some versions require non-silent)
  hyprctl dispatch togglespecialworkspace __TEMP || true
  hyprctl dispatch togglespecialworkspace __TEMP || true
  hyprctl dispatch movetoworkspace "${OLD_WS},address:${ADDR}" || true
  hyprctl dispatch workspace "$OLD_WS"
  hyprctl dispatch focuswindow "address:${ADDR}" || true
  rm -f "$STATE_FILE"
  dbg "Fallback restore attempted."
  exit 0
fi

# 最后：窗口在别的普通 workspace -> 直接切过去并 focus
dbg "Window in other workspace ($WIN_WS) -> switch and focus"
hyprctl dispatch workspace "$WIN_WS"
hyprctl dispatch focuswindow "address:${ADDR}"
exit 0

```



# 你要做的（快速）

1. 把脚本保存并 `chmod +x ~/scripts/wechat-toggle.sh`。
    
2. 在 `hyprland.conf` 里绑定（例）：
```
bind = SUPER, W, exec, ~/scripts/wechat-toggle.sh wechat

```

3. 触发一次隐藏和恢复，若**还不能隐藏**，把这两个命令的输出贴上来（我直接看日志和状态）：
```shell
cat /tmp/hypr_toggle_debug.log
hyprctl clients -j | jq '.[] | {class: .class, address: .address, ws: .workspace.id, name: .workspace.name, floating: .floating}'
hyprctl activeworkspace -j

```

（把输出直接复制粘贴到聊天窗口就行）


# 其他注意点（常见坑）

- `jq` 必须安装；脚本用了 `hyprctl clients -j` 的 JSON 输出来精确定位窗口。
    
- 有些 Hyprland 版本对 `movetoworkspacesilent`（尤其跟 special 配合）行为不一致；脚本里做了回退（先试 silent，再用 movetoworkspace + 切回）。文档和 issue 都有相关提到。[Hyprland Wiki+1](https://wiki.hypr.land/0.18.0beta/Configuring/Dispatchers/?utm_source=chatgpt.com)
    
- special workspace 对浮动/tiling 的处理有特别规则（可能导致窗口在 special 里不能是浮动），因此恢复时需要明确 `movetoworkspace <ws>,address:...` 或者 focus 后用 `settiled`/`setfloating`（这些 dispatcher 在你的 hyprland 版本里是否可用请检查）

先把上面的脚本跑一下，然后把 `/tmp/hypr_toggle_debug.log` 和 `hyprctl clients -j | jq ...` 的输出贴上来。我会基于真实输出做针对性修正（通常问题就是 “movetoworkspacesilent + special 不生效” 或 “window spec 没写成 address:...” 两类之一）。


+++++++++++++++++++++++++++++++++++++++++++++++++



现在可以了


###### ChatGPT said:

太好了 🎉！那就说明之前的问题确实是 Hyprland 的 `special` + `movetoworkspacesilent` 行为不一致导致的，现在用带回退逻辑的脚本就稳住了。

总结一下你现在的方案：

- **隐藏**：窗口从当前 workspace 移到 `special`，同时保持你原本的 workspace 不切换。
    
- **恢复**：根据保存的状态把窗口移回原 workspace，并自动聚焦。
    
- **可靠性**：加了回退逻辑，就算某些 Hyprland 版本对 `movetoworkspacesilent special,...` 不支持，也能靠 fallback 正常工作。




要不要我再帮你整理一个更**精简版**的脚本（去掉 debug 和多余分支，方便长期使用），还是保留现在这个带日志的版本（方便以后出问题时排查）？


好的



👌 那我帮你整理一个 **精简稳定版** 脚本，保留核心逻辑，把调试日志去掉，方便日常使用。

保存为 `~/scripts/toggle-app.sh` 并 `chmod +x`：


```shell
#!/usr/bin/env bash
set -euo pipefail

APP="$1"
STATE_DIR="/tmp/hypr_toggle_states"
mkdir -p "$STATE_DIR"

# 找到第一个匹配窗口
WIN_JSON=$(hyprctl clients -j)
ADDR=$(echo "$WIN_JSON" | jq -r --arg app "$APP" '
  .[] | select((.class // "" | ascii_downcase) == ($app|ascii_downcase)) | .address' | head -n1)

if [ -z "$ADDR" ] || [ "$ADDR" = "null" ]; then
  # 没找到就启动应用（按需改为你的启动命令）
  $APP & disown
  exit 0
fi

WIN_WS=$(echo "$WIN_JSON" | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | .workspace.id')
CUR_WS=$(hyprctl activeworkspace -j | jq -r .id)
STATE_FILE="$STATE_DIR/${ADDR}.state"

# helper: 确认窗口现在在哪个 workspace
where_is() {
  hyprctl clients -j | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | (.workspace.id // "-1")'
}

# 如果窗口在当前 workspace -> 隐藏
if [ "$WIN_WS" -eq "$CUR_WS" ]; then
  echo "$CUR_WS" > "$STATE_FILE"

  # 优先 silent 方法
  if hyprctl dispatch movetoworkspacesilent "special,address:${ADDR}" >/dev/null 2>&1; then
    exit 0
  fi

  # 回退：movetoworkspace special，然后切回原 ws
  hyprctl dispatch movetoworkspace "special,address:${ADDR}"
  hyprctl dispatch workspace "$CUR_WS"
  exit 0
fi

# 如果窗口在 special -> 恢复
WIN_WS_NAME=$(echo "$WIN_JSON" | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | (.workspace.name // "")')
if [ "$WIN_WS" = "-1" ] || echo "$WIN_WS_NAME" | grep -qi "special"; then
  OLD_WS="$CUR_WS"
  [ -f "$STATE_FILE" ] && OLD_WS=$(cat "$STATE_FILE")

  hyprctl dispatch movetoworkspacesilent "${OLD_WS},address:${ADDR}" || \
    hyprctl dispatch movetoworkspace "${OLD_WS},address:${ADDR}"

  hyprctl dispatch workspace "$OLD_WS"
  hyprctl dispatch focuswindow "address:${ADDR}"
  rm -f "$STATE_FILE"
  exit 0
fi

# 否则：窗口在别的 workspace -> 切过去并聚焦
hyprctl dispatch workspace "$WIN_WS"
hyprctl dispatch focuswindow "address:${ADDR}"
exit 0

```



### 使用方法

1. 保存并赋权：
```shell
chmod +x ~/scripts/toggle-app.sh
```
2. Hyprland 配置里加绑定，例如微信：
```shell
bind = SUPER, W, exec, ~/scripts/toggle-app.sh wechat
```

（`wechat` 要和 `hyprctl clients -j` 里 `.class` 名一致，比如 `WeChat.exe`，可以调一下）



这样就是一个干净的「一键隐藏/恢复/启动」脚本了。

要不要我再帮你写一个 **通用版本**，支持多个 app（比如 SUPER+F 打开/隐藏 Firefox，SUPER+T 打开/隐藏 Telegram），只用一个脚本就够？


好的

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

			版本1 
			聊天窗口固定在一个workspace 在其他Workspace按快捷键回到这个workspace
			
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

👌 那我给你整理一个 **通用多应用版本**，只用一个脚本就能管理多个应用的「启动 → 隐藏 → 恢复」逻辑。


脚本：`~/scripts/toggle-app.sh`

```shell
#!/usr/bin/env bash
set -euo pipefail

STATE_DIR="/tmp/hypr_toggle_states"
mkdir -p "$STATE_DIR"

APP="$1"   # 第一个参数是应用名，比如 wechat/firefox/telegram
CMD="$2"   # 第二个参数是启动命令，比如 wechat/firefox/telegram-desktop

# 找窗口
WIN_JSON=$(hyprctl clients -j)
ADDR=$(echo "$WIN_JSON" | jq -r --arg app "$APP" '
  .[] | select((.class // "" | ascii_downcase) == ($app|ascii_downcase)) | .address' | head -n1)

if [ -z "$ADDR" ] || [ "$ADDR" = "null" ]; then
  # 没找到窗口就启动
  eval "$CMD & disown"
  exit 0
fi

WIN_WS=$(echo "$WIN_JSON" | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | .workspace.id')
CUR_WS=$(hyprctl activeworkspace -j | jq -r .id)
STATE_FILE="$STATE_DIR/${ADDR}.state"

# Helper: 确认窗口在哪个 workspace
where_is() {
  hyprctl clients -j | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | (.workspace.id // "-1")'
}

# 如果窗口在当前 workspace -> 隐藏
if [ "$WIN_WS" -eq "$CUR_WS" ]; then
  echo "$CUR_WS" > "$STATE_FILE"

  if hyprctl dispatch movetoworkspacesilent "special,address:${ADDR}" >/dev/null 2>&1; then
    exit 0
  fi

  hyprctl dispatch movetoworkspace "special,address:${ADDR}"
  hyprctl dispatch workspace "$CUR_WS"
  exit 0
fi

# 如果窗口在 special -> 恢复
WIN_WS_NAME=$(echo "$WIN_JSON" | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | (.workspace.name // "")')
if [ "$WIN_WS" = "-1" ] || echo "$WIN_WS_NAME" | grep -qi "special"; then
  OLD_WS="$CUR_WS"
  [ -f "$STATE_FILE" ] && OLD_WS=$(cat "$STATE_FILE")

  hyprctl dispatch movetoworkspacesilent "${OLD_WS},address:${ADDR}" || \
    hyprctl dispatch movetoworkspace "${OLD_WS},address:${ADDR}"

  hyprctl dispatch workspace "$OLD_WS"
  hyprctl dispatch focuswindow "address:${ADDR}"
  rm -f "$STATE_FILE"
  exit 0
fi

# 窗口在别的 workspace -> 切过去并聚焦
hyprctl dispatch workspace "$WIN_WS"
hyprctl dispatch focuswindow "address:${ADDR}"
exit 0

```


## 用法示例

假设你要给微信 / Firefox / Telegram 设置快捷键：

### Hyprland 配置

```shell
# SUPER+W -> 微信
bind = SUPER, W, exec, ~/scripts/toggle-app.sh wechat "wechat"

# SUPER+F -> Firefox
bind = SUPER, F, exec, ~/scripts/toggle-app.sh firefox "firefox"

# SUPER+T -> Telegram
bind = SUPER, T, exec, ~/scripts/toggle-app.sh telegram "telegram-desktop"

```


## 说明

- 第一个参数 `$1` 用来匹配窗口的 **class 名**（通过 `hyprctl clients -j | jq '.[].class'` 查看实际值）。
    
- 第二个参数 `$2` 是应用的启动命令。
    
- 这样一个脚本就能管理多个应用，配置文件里只需要传不同参数即可。
    
- 如果你有 Wine/Deepin 的微信，可以写成：
```shell
bind = SUPER, W, exec, ~/scripts/toggle-app.sh wechat "/opt/deepinwine/apps/Deepin-WeChat/wechat"
```


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



要不要我帮你写一个 **自动配置检测工具**，比如输入应用名就能输出它的 class 和你需要写在绑定里的命令？这样可以快速调试微信这种特殊的 Wine 应用。


好的



👌 那我帮你写一个 **自动检测工具**，可以快速找出某个应用窗口的 `class` 和启动命令，方便配置到脚本里。



脚本：`~/scripts/find-app-class.sh`


```shell
#!/usr/bin/env bash
set -euo pipefail

APP="${1:-}"

if [ -z "$APP" ]; then
  echo "用法: $0 <关键字>"
  echo "例如: $0 wechat"
  exit 1
fi

echo "正在查找包含 '$APP' 的窗口..."

hyprctl clients -j | jq -r --arg app "$APP" '
  .[]
  | select(
      (.class // "" | ascii_downcase | contains($app|ascii_downcase))
      or
      (.title // "" | ascii_downcase | contains($app|ascii_downcase))
    )
  | "class=\(.class)  title=\(.title)  address=\(.address)  ws=\(.workspace.id)"'

```


## 用法

```shell
chmod +x ~/scripts/find-app-class.sh
~/scripts/find-app-class.sh wechat

```

输出示例（不同应用会不一样）：
```shell
class=WeChat.exe  title=微信  address=0x55a6f3b  ws=2

```

这样你就知道：

- `class` 是 `WeChat.exe`，那么在 `toggle-app.sh` 里传参要写 `WeChat.exe`（大小写敏感！）。
    
- 启动命令则是你平时运行微信的命令，比如 `/opt/deepinwine/apps/Deepin-WeChat/wechat`。

## 配置 Hyprland 绑定

拿到结果后，比如你发现微信的 class 是 `WeChat.exe`，就写：

```shell
bind = SUPER, W, exec, ~/scripts/toggle-app.sh WeChat.exe "/opt/deepinwine/apps/Deepin-WeChat/wechat"

```

这样脚本才能正确匹配窗口。




++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

版本2的需求  用法可以使用参考1  快捷键调用时，传连个参数

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


我想在一个workspace 按对应快捷键时 wechat窗口就出现在对应的workspace 而不是一直出现在那个初始的workspace

明白 ✅  
你现在想要的逻辑是：

- 每个 workspace 上按快捷键 → 微信窗口「瞬移」到这个 workspace（而不是总是回到它最初启动的 workspace）。
    
- 这样你可以在 **任意 workspace** 上「召唤」微信，它就会出现在你当前所在的 workspace。


## 思路

核心是把「恢复逻辑」改掉：

- 以前我们保存了 **最初 workspace** 并把窗口恢复到那里。
    
- 现在要改成：**恢复时总是移动到当前 workspace**（也就是你按快捷键的 workspace）。


## 修改版脚本（关键变化）

`~/scripts/toggle-app.sh`

```shell
#!/usr/bin/env bash
set -euo pipefail

STATE_DIR="/tmp/hypr_toggle_states"
mkdir -p "$STATE_DIR"

APP="$1"
CMD="$2"

WIN_JSON=$(hyprctl clients -j)
ADDR=$(echo "$WIN_JSON" | jq -r --arg app "$APP" '
  .[] | select((.class // "" | ascii_downcase) == ($app|ascii_downcase)) | .address' | head -n1)

if [ -z "$ADDR" ] || [ "$ADDR" = "null" ]; then
  eval "$CMD & disown"
  exit 0
fi

WIN_WS=$(echo "$WIN_JSON" | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | .workspace.id')
CUR_WS=$(hyprctl activeworkspace -j | jq -r .id)
STATE_FILE="$STATE_DIR/${ADDR}.state"

# 如果窗口在当前 workspace → 隐藏
if [ "$WIN_WS" -eq "$CUR_WS" ]; then
  echo "hidden" > "$STATE_FILE"
  hyprctl dispatch movetoworkspacesilent "special,address:${ADDR}" || \
    { hyprctl dispatch movetoworkspace "special,address:${ADDR}"; hyprctl dispatch workspace "$CUR_WS"; }
  exit 0
fi

# 如果窗口在 special → 恢复到 **当前 workspace**
WIN_WS_NAME=$(echo "$WIN_JSON" | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | (.workspace.name // "")')
if [ "$WIN_WS" = "-1" ] || echo "$WIN_WS_NAME" | grep -qi "special"; then
  hyprctl dispatch movetoworkspacesilent "${CUR_WS},address:${ADDR}" || \
    hyprctl dispatch movetoworkspace "${CUR_WS},address:${ADDR}"

  hyprctl dispatch focuswindow "address:${ADDR}"
  rm -f "$STATE_FILE"
  exit 0
fi

# 如果窗口在其他 workspace → 移动到 **当前 workspace**
hyprctl dispatch movetoworkspacesilent "${CUR_WS},address:${ADDR}" || \
  hyprctl dispatch movetoworkspace "${CUR_WS},address:${ADDR}"

hyprctl dispatch focuswindow "address:${ADDR}"

```


## 使用方式

还是和之前一样：

```shell
bind = SUPER, W, exec, ~/scripts/toggle-app.sh WeChat.exe "/opt/deepinwine/apps/Deepin-WeChat/wechat"

```


效果就是：

- 在任意 workspace 按下快捷键，
    
    - 如果微信在前台 → 隐藏到 special
        
    - 如果微信被隐藏 → 恢复到「当前 workspace」
        
    - 如果微信在别的 workspace → 把它移到「当前 workspace」


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

			                 版本 2
		聊天窗口不固定在一个workspace 
		在其他Workspace按快捷键 聊天窗口 会在对应的workspace出现

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


如果是隐藏的状态 按快捷键 也要出现在当前workspace 而不是之前的workspace



对的 👍 你要的逻辑是：

- **隐藏时** → 放到 `special`
    
- **再按快捷键恢复时** → 永远回到「当前 workspace」而不是之前启动的那个
    

上次脚本里已经部分改了，但恢复时我还保留了检查 `WIN_WS_NAME` 的逻辑（可能导致回到旧 workspace）。  
咱们直接彻底改掉：只要在 `special` → 一律移到 **当前 workspace**。


### 脚本更新版

`~/scripts/toggle-app.sh`

```shell
#!/usr/bin/env bash
set -euo pipefail

APP="$1"
CMD="$2"

WIN_JSON=$(hyprctl clients -j)
ADDR=$(echo "$WIN_JSON" | jq -r --arg app "$APP" '
  .[] | select((.class // "" | ascii_downcase) == ($app|ascii_downcase)) | .address' | head -n1)

if [ -z "$ADDR" ] || [ "$ADDR" = "null" ]; then
  # 没有运行 → 启动
  eval "$CMD & disown"
  exit 0
fi

WIN_WS=$(echo "$WIN_JSON" | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | .workspace.id')
CUR_WS=$(hyprctl activeworkspace -j | jq -r .id)

# 情况 1: 在当前 workspace → 隐藏到 special
if [ "$WIN_WS" -eq "$CUR_WS" ]; then
  hyprctl dispatch movetoworkspacesilent "special,address:${ADDR}" || \
    { hyprctl dispatch movetoworkspace "special,address:${ADDR}"; hyprctl dispatch workspace "$CUR_WS"; }
  exit 0
fi

# 情况 2: 在 special → 恢复到当前 workspace
if [ "$WIN_WS" = "-1" ]; then
  hyprctl dispatch movetoworkspacesilent "${CUR_WS},address:${ADDR}" || \
    hyprctl dispatch movetoworkspace "${CUR_WS},address:${ADDR}"
  hyprctl dispatch focuswindow "address:${ADDR}"
  exit 0
fi

# 情况 3: 在别的 workspace → 直接拉到当前 workspace
hyprctl dispatch movetoworkspacesilent "${CUR_WS},address:${ADDR}" || \
  hyprctl dispatch movetoworkspace "${CUR_WS},address:${ADDR}"
hyprctl dispatch focuswindow "address:${ADDR}"

```


### 绑定示例

`hyprland.conf`:

```shell
bind = SUPER, W, exec, ~/scripts/toggle-app.sh WeChat.exe "/opt/deepinwine/apps/Deepin-WeChat/wechat"

```

### 效果

- **在当前 workspace** → 按下快捷键 → 隐藏到 `special`
    
- **再按快捷键** → 从 `special` 拉回来 → **当前 workspace**
    
- **在别的 workspace** → 按快捷键 → 微信窗口会「瞬移」过来



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


要不要我帮你扩展一下，把 APP class 名 + 启动命令 配置到一个数组里，这样同一个脚本就能管理多个应用（比如微信、Telegram、Slack、QQ）？

好的



👌 那我们做一个「多应用通用版」的脚本，你只需要在数组里配置好应用的 **class 名称** 和 **启动命令**，就能用同一份 `toggle-app.sh` 来控制微信、Telegram、Slack、QQ 等。

---

## 脚本：`~/scripts/toggle-app.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

# 在这里配置应用列表：class 名称 => 启动命令
declare -A apps=(
  ["WeChat.exe"]="/opt/deepinwine/apps/Deepin-WeChat/wechat"
  ["telegram-desktop"]="telegram-desktop"
  ["slack"]="slack"
  ["qq"]="qq"
)

APP="$1"

if [[ -z "${apps[$APP]+isset}" ]]; then
  echo "未知应用: $APP"
  echo "可用: ${!apps[@]}"
  exit 1
fi

CMD="${apps[$APP]}"

WIN_JSON=$(hyprctl clients -j)
ADDR=$(echo "$WIN_JSON" | jq -r --arg app "$APP" '
  .[] | select((.class // "" | ascii_downcase) == ($app|ascii_downcase)) | .address' | head -n1)

if [ -z "$ADDR" ] || [ "$ADDR" = "null" ]; then
  # 没有运行 → 启动
  eval "$CMD & disown"
  exit 0
fi

WIN_WS=$(echo "$WIN_JSON" | jq -r --arg addr "$ADDR" '.[] | select(.address==$addr) | .workspace.id')
CUR_WS=$(hyprctl activeworkspace -j | jq -r .id)

# 情况 1: 在当前 workspace → 隐藏到 special
if [ "$WIN_WS" -eq "$CUR_WS" ]; then
  hyprctl dispatch movetoworkspacesilent "special,address:${ADDR}" || \
    { hyprctl dispatch movetoworkspace "special,address:${ADDR}"; hyprctl dispatch workspace "$CUR_WS"; }
  exit 0
fi

# 情况 2: 在 special → 恢复到当前 workspace
if [ "$WIN_WS" = "-1" ]; then
  hyprctl dispatch movetoworkspacesilent "${CUR_WS},address:${ADDR}" || \
    hyprctl dispatch movetoworkspace "${CUR_WS},address:${ADDR}"
  hyprctl dispatch focuswindow "address:${ADDR}"
  exit 0
fi

# 情况 3: 在别的 workspace → 直接拉到当前 workspace
hyprctl dispatch movetoworkspacesilent "${CUR_WS},address:${ADDR}" || \
  hyprctl dispatch movetoworkspace "${CUR_WS},address:${ADDR}"
hyprctl dispatch focuswindow "address:${ADDR}"
```

---

## 使用方式（绑定快捷键）

在 `hyprland.conf` 里加：

```ini
# 微信
bind = SUPER, W, exec, ~/scripts/toggle-app.sh WeChat.exe
# Telegram
bind = SUPER, T, exec, ~/scripts/toggle-app.sh telegram-desktop
# Slack
bind = SUPER, S, exec, ~/scripts/toggle-app.sh slack
# QQ
bind = SUPER, Q, exec, ~/scripts/toggle-app.sh qq
```

---

## 效果

- 按下对应快捷键：
    
    - 如果应用没启动 → 启动
        
    - 如果在当前 workspace → 隐藏到 `special`
        
    - 如果在 `special` → 拉回 **当前 workspace**
        
    - 如果在别的 workspace → 拉到 **当前 workspace**
        

---

